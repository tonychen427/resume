(window.webpackJsonp=window.webpackJsonp||[]).push([[0],Array(139).concat([function(n,e){n.exports="// Given a non-empty array of integers, every element appears twice except for one. Find that single one.\n\n// Note:\n\n// Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n\n// Example 1:\n\n// Input: [2,2,1]\n// Output: 1\n// Example 2:\n\n// Input: [4,1,2,1,2]\n// Output: 4\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function(nums) {\n    let min = '';\n    let map = {};\n    for (let i = 0 ; i < nums.length; i++) {\n        if(map[nums[i]] === undefined) {\n\n        }\n    }\n    return min;\n };\n\n\nconsole.log(singleNumber([1,2,2,3,1]));"},function(n,e){n.exports="// Given an array of size n, find the majority element. The majority element is the element that appears more than \u230a n/2 \u230b times.\n\n// You may assume that the array is non-empty and the majority element always exist in the array.\n\n// Example 1:\n\n// Input: [3,2,3]\n// Output: 3\n// Example 2:\n\n// Input: [2,2,1,1,1,2,2]\n// Output: 2\n\nvar majorityElement = function(nums) {\n    let map = {};\n    let result = nums[0];\n    let time = 0;\n    for (let i = 0; i < nums.length; i++) {\n        map[nums[i]] = map[nums[i]] === undefined ? 0 : map[nums[i]] + 1;\n        if (map[nums[i]] > time) {\n            result = nums[i];\n            time = map[nums[i]];\n        }\n    }\n    return result;\n};\n\nconsole.log(majorityElement([1,1,3,3,3,3,3]));\n\n\n\n"},function(n,e){n.exports="// Given an array, rotate the array to the right by k steps, where k is non-negative.\n\n// Example 1:\n\n// Input: [1,2,3,4,5,6,7] and k = 3\n// Output: [5,6,7,1,2,3,4]\n// Explanation:\n// rotate 1 steps to the right: [7,1,2,3,4,5,6]\n// rotate 2 steps to the right: [6,7,1,2,3,4,5]\n// rotate 3 steps to the right: [5,6,7,1,2,3,4]\n\nconst rotate = (nums, k) => {\n    for (let i = 0; i < k; i++) {\n        let temp = nums.pop();\n        nums.unshift(temp);\n    }\n};\nconsole.log(rotate([0], 1));"},function(n,e){n.exports='// Given a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid.\n\n// An input string is valid if:\n\n// Open brackets must be closed by the same type of brackets.\n// Open brackets must be closed in the correct order.\n// Note that an empty string is also considered valid.\n\n\n// Input: "()[]{}"\n// Output: true\n// Example 3:\n\n// Input: "(]"\n// Output: false\n// Example 4:\n\n// Input: "([)]"\n// Output: false\n// Example 5:\n\nconst isValidParentheses = (lastChar, current) => {\n    return (lastChar === "{" && current === "}") || (lastChar === "(" && current === ")") || (lastChar === "[" && current === "]")\n}\nvar isValid = function(s) {\n    let stack = [];\n    for (let i = 0; i < s.length; i++) {\n        if ("({[".includes(s[i])) {\n            stack.push(s[i]);\n        } else {\n            if (!isValidParentheses(stack[stack.length - 1], s[i])) { console.log(\'nn\'); return false }\n            stack.pop();\n        }\n    }\n    return stack.length === 0;\n};\n\nconsole.log(isValid("{{}}"));\nconsole.log(isValid("{}[]()"));'},function(n,e){n.exports="// Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\n\n// Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n\n// Example 1:\n\n// Given nums = [1,1,2],\n\n// Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\n\n// It doesn't matter what you leave beyond the returned length.\n// Example 2:\n\n// Given nums = [0,0,1,1,1,2,2,3,3,4],\n\n// Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.\n\n// It doesn't matter what values are set beyond the returned length.\n\n/**\n * @param {number[]} nums\n * @return {number} the length or nums;\n */\n\nvar removeDuplicates = function(nums) {\n    if (!nums.length) return 0;\n    let count = 1;\n    for (let i=1; i<nums.length; i++) {\n        if (nums[i] !== nums[i-1]) {\n            nums[count] = nums[i];\n            count++;\n        }\n    }\n    return count;\n};\n\nconsole.log(removeDuplicates(null));"},function(n,e){n.exports="// Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\n// Example:\n\n// Input: [0,1,0,3,12]\n// Output: [1,3,12,0,0]\n// Note:\n\n// You must do this in-place without making a copy of the array.\n// Minimize the total number of operations.\n\nvar moveZeroes = function(nums) {  \n    for (let i = nums.length; i > 0; i--) {\n        if(nums[i] === 0) {\n            let temp = nums.splice(i, 1);\n            nums.push(temp);\n        }\n    }\n}\nconsole.log(moveZeroes([0]));"},function(n,e){n.exports="// Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\n\n// Your algorithm's runtime complexity must be in the order of O(log n).\n\n// If the target is not found in the array, return [-1, -1].\n\n// Example 1:\n\n// Input: nums = [5,7,7,8,8,10], target = 8\n// Output: [3,4]\n// Example 2:\n\n// Input: nums = [5,7,7,8,8,10], target = 6\n// Output: [-1,-1]\n\nvar searchRange = function(nums, target) {\n    if (nums.length === 0) return [-1,-1];\n    let first = 0;\n    let last = nums.length - 1;\n    let startIndex = -1;\n    let endIndex = -1;\n    for (let i = 0; i < nums.length; i++) {\n         if (nums[first] === target) {\n             startIndex = first;\n         } else {\n             first++;\n         }\n         if (nums[last] === target) {\n             endIndex = last;\n         } else {\n             last--;\n         }\n    }\n    return [startIndex, endIndex];\n }\n console.log(searchRange([],0));"},function(n,e){n.exports="// Given a non-empty array of digits representing a non-negative integer, plus one to the integer.\n\n// The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\n\n// You may assume the integer does not contain any leading zero, except the number 0 itself.\n\n// Example 1:\n\n// Input: [1,2,3]\n// Output: [1,2,4]\n// Explanation: The array represents the integer 123.\n// Example 2:\n\n// Input: [4,3,2,1]\n// Output: [4,3,2,2]\n// Explanation: The array represents the integer 4321.\n\n/**\n * @param {number[]} digits\n * @return {number[]}\n */\n\nvar plusOne = function(digits) {\n    let result = [];\n    let current = 0;\n    let carryOver = 0;\n    for (let i = digits.length - 1; i >= 0; i--) {\n        current = digits[i] + carryOver;\n        if (i ===  digits.length - 1) {\n            current = current + 1;\n        }\n        if (Math.floor(current / 10) > 0) {\n            carryOver = Math.floor(current / 10);\n            result.unshift(current % 10);\n        } else {\n            result.unshift(current);\n            carryOver = 0;\n        }\n    }\n    if (carryOver > 0) {\n        result.unshift(carryOver);\n    }\n    return result;\n}; \nconsole.log(plusOne([9,9]));"},function(n,e){n.exports='// Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n//\n// For example, given n = 3, a solution set is:\n//\n//   [\n//     "((()))",\n//     "(()())",\n//     "(())()",\n//     "()(())",\n//     "()()()"\n//   ]\n\n/**\n * @param {number} n\n * @return {string[]}\n */\n const buildParenthesis =  (left, right, subset, result) => {\n     if (right < left) return;\n\n     if (right === null && left === null) return result.push(subset.slice());\n\n     if (left !== null) buildParenthesis(left - 1, right, \'(\', result);\n     if (right !== null) buildParenthesis(left, right - 1, \')\', result);\n }\n const generateParenthesis = number => {\n     if (number === null || number === 0) return [];\n\n     let result = [];\n     buildParenthesis(number, number, [], result);\n     return result;\n }\n\n console.log(generateParenthesis(3));'},function(n,e){n.exports="// Given a set of distinct integers, nums, return all possible subsets (the power set).\n\n// Note: The solution set must not contain duplicate subsets.\n\n// Example:\n\n// Input: nums = [1,2,3]\n// Output:\n// [\n//   [3],\n//   [1],\n//   [2],\n//   [1,2,3],\n//   [1,3],\n//   [2,3],\n//   [1,2],\n//   []\n// ]\n\n// time = O(2^n)\n// space = O(n)\n\nconst dfs = (nums, startIndex, list, result) => {\n    // sanity check and return the data to stop the recursion\n    if(startIndex === nums.length) { result.push(list.slice()); return; }\n\n    // core logic\n    \n    dfs(nums, startIndex + 1, list, result);\n    list.push(nums[startIndex]);\n    dfs(nums, startIndex + 1, list, result);\n    list.pop();\n}\n\nvar subsets = function(nums) {\n    // sanity check\n    if (nums === null || nums.length === 0) return [];\n\n    let result = [];\n\n    // depth first search\n    dfs(nums, 0, [], result);\n\n    // return subset;\n    return result;\n};\n\nconsole.log(subsets([1,2,3]));\n\n// -------------------------------------------\n// [\n//  [],\n//  [3],\n//  [2],\n//  [2,3],\n//  [1],\n//  [1,3]\n//  [1,2]\n//  [1,2,3],\n// ]\nconst dfs2 = (nums, startIndex, subset, result) =>{\n    result.push(subset.slice());\n    for (let i = startIndex; i < nums.length; i++) {\n        subset.push(nums[i]);\n        dfs2(nums, startIndex, subset, result);\n        subset.pop();\n    }\n}\nconst subset2 = nums => {\n    if (nums === null || nums.length === 0)  return [];\n    \n    let result = [];\n    dfs2(nums, 0, [], result);\n    return result;\n}\n\nconsole.log(subset2([1,2,3]));"},function(n,e){n.exports="\n// Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\n\n// Note: The solution set must not contain duplicate subsets.\n\n// Example:\n\n// Input: [1,2,2]\n// Output:\n// [\n//   [2],\n//   [1],\n//   [1,2,2],\n//   [2,2],\n//   [1,2],\n//   []\n// ]\n\nvar dfs = function(nums,index, temp, res){\n    let lastpopped\n    res.push(temp.slice());\n    for (let i=index;i<nums.length;i++){        \n        if(nums[i] === lastpopped) { continue; }\n        temp.push(nums[i]);\n        dfs(nums, i + 1, temp, res);\n        lastpopped = temp.pop();\n    }\n}\n\nvar subsetsWithDup = function(nums) {\n    let result = [];\n    if (nums.length === 0 && nums === null) return result;\n    nums.sort((a,b) => a - b);\n    dfs(nums, 0, [], result);\n    return result;\n};\n\nconsole.log(subsetsWithDup([1,2,2]));\n\n// --------------------------------------------\n\nconst dfs2 = (nums, index, subset, result) =>{\n    result.push(subset.slice());\n    for (let i = index; i < nums.length; i++){\n        if (i !== index && nums[i] === nums[i-1]) continue;\n        subset.push(nums[i]);\n        dfs2(nums, i + 1, subset, result);\n        subset.pop();\n    }\n}\nconst subsetsWithDup2 = nums => {\n    if (nums === null || nums.length === 0) { return []; }\n    nums.sort((a, b) =>  a - b);\n    let result = [];\n    dfs2(nums, 0, [], result);\n    return result;\n}\nconsole.log(subsetsWithDup2([1,2,2]));"},function(n,e){n.exports="// Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.\n\n// Example 1:\n\n// Input: nums = [-1,0,3,5,9,12], target = 9\n// Output: 4\n// Explanation: 9 exists in nums and its index is 4\n\nconst search = (nums, target) => {\n    let start = 0, end = nums.length - 1, middle;\n    while (start < end) {\n        middle = Math.floor((start+end) / 2);\n        if (nums[middle] === target) { return middle; }\n        if (nums[middle] < target) {\n            start = middle + 1;\n        } else { \n            end = middle - 1;\n        }\n    }\n    return -1;\n}\nconsole.log(search([1,2,3,4,5,6], 9));"},function(n,e){n.exports="// Given two binary trees, write a function to check if they are the same or not.\n\n// Two binary trees are considered the same if they are structurally identical and the nodes have the same value.\n\n// Example 1:\n\n// Input:     1         1\n//           / \\       / \\\n//          2   3     2   3\n\n//         [1,2,3],   [1,2,3]\n\n// Output: true\n// Example 2:\n\n// Input:     1         1\n//           /           \\\n//          2             2\n\n//         [1,2],     [1,null,2]\n\n// Output: false\n// Example 3:\n\n// Input:     1         1\n//           / \\       / \\\n//          2   1     1   2\n\n//         [1,2,1],   [1,1,2]\n\n// Output: false\n\nconst isSameTree = (tree1, tree2) => {\n    if (tree1 === null || tree2 === null) { return true; }\n    if ((tree1 !== null && tree2 === null) && (tree1 === null && tree2 !== null)) { return false; }\n    if (tree1.val !== tree2.val) { return false; }\n    return isSameTree(tree1.left, tree2.left) && isSameTree(tree1.right, tree2.right);\n}"},function(n,e){n.exports="// mirror of itself (ie, symmetric around its center).\n\n// For example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n\n//     1\n//    / \\\n//   2   2\n//  / \\ / \\\n// 3  4 4  3\n// But the following [1,2,2,null,3,null,3] is not:\n//     1\n//    / \\\n//   2   2\n//    \\   \\\n//    3    3\n\nconst reverseHelper = head => {\n    if (head === null) return head;\n    let temp = head.left;\n    head.left = reverseHelper(head.right);\n    head.right = reverseHelper(temp);\n    return head;\n}\nconst sameTree = (node1, node2) => {\n    if (node1 === null && node2 === null) {\n        return true;\n    }\n    if ((node1 !== null && node2 === null) || (node1 === null && node2 !== null)) {\n        return false;\n    }\n    if (node1.val !== node2.val) {\n        return false;\n    }\n    return sameTree(node1.left, node2.left)  && sameTree(node1.right, node2.right);\n}\n\nvar isSymmetric = function(root) {  \n    if (root === null) return true;\n    let reverseTree = reverseHelper(root.left);\n    return sameTree(reverseTree, root.right);\n}\n\nconsole.log(isSymmetric(null));"},function(n,e){n.exports="// Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\n\n// For example:\n// Given binary tree [3,9,20,null,null,15,7],\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its level order traversal as:\n// [\n//   [3],\n//   [9,20],\n//   [15,7]\n// ]\n\nfunction TreeNode(val){\n    this.val = val;\n    this.right = null;\n    this.left = null;\n}\nconst levelOrder = root => {\n    if (root === null) return [];\n    let result = [];\n    let queue = [root];\n    while (queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right)}\n        }\n        result.push(current);\n    }\n    return result;\n}\n\nconst levelOrders2 = root => {\n    // sanity check\n    if (root === null ) return [];\n    let result = [];\n    let queue = [root];\n    while(queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let node = queue.pop();\n            current.push(node.val);\n            if (node.left !== null) { queue.push(node.left); }\n            if (node.right !== null) { queue.push(node.right); }\n        }\n        result.push(current);\n    }\n    return result;\n }\n\n // Given binary tree [3,9,20,null,null,15,7],\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its level order traversal as:\n// [\n//   [3],\n//   [9,20],\n//   [15,7]\n// ]\nconst n1 = new TreeNode(3);\nconst n2 = new TreeNode(9);\nconst n3 = new TreeNode(20);\nconst n4 = new TreeNode(15);\nconst n5 = new TreeNode(7);\n\nn1.left = n2;\nn1.right = n3;\nn3.left = n4;\nn3.right = n5;\n\nconsole.log(levelOrders2(n1));\n"},function(n,e){n.exports="// Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\n\n// For example:\n// Given binary tree [3,9,20,null,null,15,7],\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its zigzag level order traversal as:\n// [\n//   [3],\n//   [20,9],\n//   [15,7]\n// ]\n\nvar zigzagLevelOrder = function(root) {\n    if (root === null) return [];\n    let result = [];\n    let queue = [root];\n    let normal = true;\n    while (queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            normal ? current.push(head.val) : current.unshift(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(current);\n        normal = !normal;\n    }\n    return result;\n}\nconsole.log(zigzagLevelOrder(null));"},function(n,e){n.exports="// Given a binary tree, find its maximum depth.\n\n// The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Given binary tree [3,9,20,null,null,15,7],\n\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its depth = 3.\n\nconst maxDepth = root => {\n    let max = 0;\n    const findMaxDepth = (node, currDepth) => {\n        if (node === null) return currDepth;\n        if (currDepth > max) { max = currDepth; }\n        if (node.left !== null) { findMaxDepth(node.left, currDepth + 1); }\n        if (node.right !== null) { findMaxDepth(node.right, currDepth + 1); }\n    }\n    findMaxDepth(root, 1);\n    return max;\n}\n\nvar maxDepth2 = function(root) {\n    if (root === null) return 0;\n    return Math.max(maxDepth2(root.left), maxDepth2(root.right)) + 1;\n};\n\nconsole.log(maxDepth(null));"},function(n,e){n.exports="// Given preorder and inorder traversal of a tree, construct the binary tree.\n\n// Note:\n// You may assume that duplicates do not exist in the tree.\n\n// For example, given\n\n// preorder = [3,9,20,15,7]\n// inorder = [9,3,15,20,7]\n// Return the following binary tree:\n\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\nconst TreeNode = (val) => {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\nconst p2iHelper = (preorder, pStart, pEnd, inorder, iStart, iEnd) => {\n    if (iStart > iEnd) return null;\n    let value = preorder[pStart];\n    let root = new TreeNode(value);\n    let position = inorder.indexOf(value); // found out where is the value index in the iorder arrary\n    root.left = p2iHelper(preorder, pStart + 1, pStart + position - iStart, inorder, iStart, position - 1);\n    root.right =  p2iHelper(preorder, position - iEnd + pEnd + 1, pEnd, inorder, position + 1 , iEnd);\n    return root;\n}\nconst buildTree = (preorder, inorder) => {\n    // sanity check\n    if (preorder.length !== inorder.length) return null;\n    \n    //base logic\n    return p2iHelper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n}\n\nconsole.log(buildTree(null,null));"},function(n,e){n.exports="// Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\n\n// For example:\n// Given binary tree [3,9,20,null,null,15,7],\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its bottom-up level order traversal as:\n// [\n//   [15,7],\n//   [9,20],\n//   [3]\n// ]\n\nconst levelOrderBottom = root => {\n    if (root === null) return [];\n    let result = [];\n    let queue = [root];\n    while(queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.unshift(current);\n    }\n    return result;\n}\nfunction TreeNode(val){\n    this.val = val;\n    this.right = null;\n    this.left = null;\n}\nconst n1 = new TreeNode(3);\nconst n2 = new TreeNode(9);\nconst n3 = new TreeNode(20);\nconst n4 = new TreeNode(15);\nconst n5 = new TreeNode(7);\n\nn1.left = n2;\nn1.right = n3;\nn3.left = n4;\nn3.right = n5;\nconsole.log(levelOrderBottom(n1));"},function(n,e){n.exports="// Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\n\n// For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n\n// Example:\n\n// Given the sorted array: [-10,-3,0,5,9],\n\n// One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:\n\n//       0\n//      / \\\n//    -3   9\n//    /   /\n//  -10  5\nconst TreeNode = (val) => {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\nconst buildBST = (nums, start, end) => {\n    if (start > end) return null;\n    let mid = Math.floor((start + end) / 2);\n    let bst = new TreeNode(nums[mid]);\n    bst.left = buildBST(nums, start, mid - 1);\n    bst.right = buildBST(nums, mid + 1, end);\n    return bst;\n}\n\nconst sortedArrayToBST = nums => {\n    if (nums.length === 0) return null;\n    return buildBST(nums, 0, nums.length - 1);\n}\n\nconsole.log(sortedArrayToBST([123]));"},function(n,e){n.exports="// Given a binary tree, find its minimum depth.\n\n// The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Given binary tree [3,9,20,null,null,15,7],\n\n//     3\n//    / \\\n//   9  20\n//     /  \\\n//    15   7\n// return its minimum depth = 2.\n\nvar minDepth = function(root) {\n    // sanity Check\n    if (root === null) return 0;\n    const left = minDepth(root.left);\n    const right = minDepth(root.right);\n    return (left === 0 || right === 0) ? (right + left ) + 1 : Math.min(left, right) + 1;\n};"},function(n,e){n.exports="// Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Given the below binary tree and sum = 22,\n\n//       5\n//      / \\\n//     4   8\n//    /   / \\\n//   11  13  4\n//  /  \\      \\\n// 7    2      1\n// return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.\n\nvar hasPathSum = function(root, sum) {\n    // sanity check\n    if (root === null) return false;\n    if (root.left === null && root.right === null && root.val === sum) return true;\n    return hasPathSum(root.left, sum - root.val) ||  hasPathSum(root.right, sum - root.val);\n}"},function(n,e){n.exports="// Given a binary tree, return the preorder traversal of its nodes' values.\n\n// Example:\n\n// Input: [1,null,2,3]\n//    1\n//     \\\n//      2\n//     /\n//    3\n\n// Output: [1,2,3]\n\nfunction TreeNode(val){\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\n\nconst preorderTraversal = root => {\n    let result = [];\n    const traversal = node => {\n        if (node === null) return result;\n        result.push(node.val);\n        traversal(node.left);\n        traversal(node.right);\n    }\n    traversal(root);\n    return result;\n}\n\nconsole.log(preorderTraversal(null));\n\n\n// preorder without recusion\nconst preOrderTraversal = root => {\n    let stack = [];\n    let inorder = [];\n\n    stack.push(root);\n    while (stack.length > 0) {\n        let node = stack.pop();\n        inorder.push(node.val);\n        if (node.right !== null) { stack.push(node.right); }\n        if (node.left !== null) { stack.push(node.left); }\n    }\n    return inorder;\n}\n\nconst tn1 = new TreeNode(1);\nconst tn2 = new TreeNode(2);\nconst tn3 = new TreeNode(3);\nconst tn4 = new TreeNode(4);\nconst tn5 = new TreeNode(5);\n\ntn1.left = tn2;\ntn1.right = tn3;\ntn2.left = tn4;\ntn2.right = tn5;\n\n//       1\n//      / \\\n//     2   3\n//    / \\\n//   4   5\n\nconsole.log(preOrderTraversal(tn1));"},function(n,e){n.exports="// Given a binary tree, return the postorder traversal of its nodes' values.\n\n// Example:\n\n// Input: [1,null,2,3]\n//    1\n//     \\\n//      2\n//     /\n//    3\n\n// Output: [3,2,1]\n\nvar postorderTraversal = function(root) {\n    let result = [];\n    const traversal = node => {\n        if (node === null) return result;\n        traversal(node.left);\n        traversal(node.right);\n        result.push(node.val);\n    }\n    traversal(root);\n    return result;\n}\nconsole.log(postorderTraversal(null));"},function(n,e){n.exports="// Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n\n// Example:\n\n// Input: [1,2,3,null,5,null,4]\n// Output: [1, 3, 4]\n// Explanation:\n\n//    1            <---\n//  /   \\\n// 2     3         <---\n//  \\     \\\n//   5     4       <---\n\n\nconst rightSideView = root => {\n    if (root === null) { return []; }\n    let result = [];\n    let queue = [root];\n    while (queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(current[current.length - 1]);\n    }\n    return result;\n}\n\nconsole.log(rightSideView(null));\n"},function(n,e){n.exports="// Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n// Example 1:\n\n// Input:\n// 11110\n// 11010\n// 11000\n// 00000\n\n// Output: 1\n// Example 2:\n\n// Input:\n// 11000\n// 11000\n// 00100\n// 00011\n\n// Output: 3\n\n// time complexity O(n^2)\nconst updateLandToWater = (grid, i, j) => {\n    if (i< 0 || i >= grid.length || j < 0 || j>= grid[0].length || grid[i][j] !== 1) {\n        return\n    }\n    grid[i][j] = 0;\n    updateLandToWater(grid, i - 1, j);\n    updateLandToWater(grid, i + 1, j);\n    updateLandToWater(grid, i, j - 1);\n    updateLandToWater(grid, i, j + 1);\n}\n\nvar numIslands = function(grid) {\n    let count = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[0].length; j++) {\n            if (grid[i][j] === 1) {\n                count++;\n                updateLandToWater(grid, i, j);\n            }\n        }\n    }\n    return count;\n};\n\nconst island = [\n    [0,0,0,1,1],\n    [0,1,0,0,0],\n    [0,1,1,0,0],\n    [0,0,0,0,0],\n    [0,0,0,1,1],\n]\n\nconsole.log(numIslands(island));\n\nconst updateIslandToWater = (grid, xcoord, ycoord) => {\n    if (xcoord < 0 || xcoord >= grid.length || ycoord < 0 || ycoord >= grid[0].length || grid[xcoord][ycoord] !== 1) {\n        return;\n    }\n    grid[xcoord][ycoord] = 0;\n    updateIslandToWater(grid, xcoord - 1, ycoord);\n    updateIslandToWater(grid, xcoord + 1, ycoord);\n    updateIslandToWater(grid, xcoord, ycoord - 1);\n    updateIslandToWater(grid, xcoord, ycoord + 1);\n}\nvar numIslands2 = function(grid) {\n    let numberIsland = 0;\n    for (let x = 0; x < grid.length; x++) {\n        for (let y = 0; y < grid[0].length; y++) {\n            if (grid[x][y] === 1) {\n                numberIsland++;\n                updateIslandToWater(grid, x, y);\n            }\n        }\n    }\n    return numberIsland;\n}\n\nconst island2 = [\n    [0,0,0,1,1],\n    [0,1,0,0,0],\n    [0,1,1,0,0],\n    [0,0,0,0,0],\n    [0,0,0,1,1],\n]\nconsole.log(numIslands2(island2));"},function(n,e){n.exports='// Given an 2D board, count how many battleships are in it. The battleships are represented with \'X\'s, empty slots are represented with \'.\'s. You may assume the following rules:\n// You receive a valid board, made of only battleships or empty slots.\n// Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n// At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n// Example:\n// X..X\n// ...X\n// ...X\n// In the above board there are 2 battleships.\n// Invalid Example:\n// ...X\n// XXXX\n// ...X\n// This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n\n/**\n * @param {character[][]} board\n * @return {number}\n */\n\nconst updateBoard = (board, x, y) => {\n    if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] !== \'X\') { return; }\n    board[x][y] = \'.\';\n    updateBoard(board, x+1, y);\n    updateBoard(board, x-1, y);\n    updateBoard(board, x, y+1);\n    updateBoard(board, x, y-1);\n}\nvar countBattleships = function(board) {\n    let count = 0;\n    for (let i = 0; i < board.length; i++){\n        for (let j = 0; j < board[0].length; j++) {\n            if (board[i][j] === \'X\') {\n                count++;\n                updateBoard(board, i, j);\n            }\n        }\n    }\n    return count;\n};\nconst board = [["X",".",".","X"],[".",".",".","X"],[".",".",".","X"]];\nconsole.log(countBattleships(board));\n\nconst countBattleships2 = board => {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[0].length; j++ ) {\n            if (board[i][j] === \'.\') { continue; }\n            if (i > 0 && board[i - 1][j] === \'X\') { continue; }\n            if (j > 0 && board[i][j - 1] === \'X\') { continue; }\n            count++;\n        }\n    }\n    return count;\n}\nconst board2 = [["X",".",".","X"],[".",".","X","X","X"],[".",".",".","X"]];\nconsole.log(countBattleships2(board2));\n'},function(n,e){n.exports="// Invert a binary tree.\n\n// Example:\n\n// Input:\n\n//      4\n//    /   \\\n//   2     7\n//  / \\   / \\\n// 1   3 6   9\n// Output:\n\n//      4\n//    /   \\\n//   7     2\n//  / \\   / \\\n// 9   6 3   1\n\nvar invertTree = function(root) {\n    // sanity check\n    if (root === null) { return root; }\n    let queue = [root];\n    while(queue.length > 0) {\n        let node = queue.shift();\n        let temp = node.left;\n        node.left = node.right;\n        node.right = temp;\n        if (node.left !== null) { queue.push(node.left); }\n        if (node.right !== null) { queue.push(node.right); }\n    }\n    return root;\n};\n\nconsole.log(invertTree(null));"},function(n,e){n.exports="// Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\n// Note: \n// You may assume k is always valid, 1 \u2264 k \u2264 BST's total elements.\n\n// Example 1:\n\n// Input: root = [3,1,4,null,2], k = 1\n//    3\n//   / \\\n//  1   4\n//   \\\n//    2\n// Output: 1\n// Example 2:\n\n// Input: root = [5,3,6,2,4,null,null,1], k = 3\n//        5\n//       / \\\n//      3   6\n//     / \\\n//    2   4\n//   /\n//  1\n// Output: 3\n\nconst kthSmallest = (root, k) => {\n    let counter = 0;\n    let kth = null;\n    let inorderTraversal = node => {\n        if (node.left !== null) { inorderTraversal(node.left); }\n        counter++;\n        if (counter === k) { kth = node; }\n        if (node.right !== null) { inorderTraversal(node.right); }\n    }\n    inorderTraversal(root);\n    return kth.val;\n}\n\nconsole.log(kthSmallest(null,0));"},function(n,e){n.exports="// Given a binary tree, return all root-to-leaf paths.\n\n// Note: A leaf is a node with no children.\n\n// Example:\n\n// Input:\n\n//    1\n//  /   \\\n// 2     3\n//  \\\n//   5\n\n// Output: [\"1->2->5\", \"1->3\"]\n\n// Explanation: All root-to-leaf paths are: 1->2->5, 1->3\n\nconst binaryTreePaths = root => {\n    // sanity check\n    var result = [];\n    if (!root) { return result; }\n    const preorderTraversal = (node, content) => {\n        if(!node.left && !node.right) { result.push(content + node.val); }\n        if (node.left !== null) { preorderTraversal(node.left, content + node.val + '->'); }\n        if (node.right !== null) { preorderTraversal(node.right, content + node.val + '->'); }\n    }\n    preorderTraversal(root, '');\n    return result;\n}\n\nconsole.log(binaryTreePaths(null));"},function(n,e){n.exports="// Given a binary tree, find the leftmost value in the last row of the tree.\n\n// Example 1:\n// Input:\n\n//     2\n//    / \\\n//   1   3\n\n// Output:\n// 1\n// Example 2: \n// Input:\n\n//         1\n//        / \\\n//       2   3\n//      /   / \\\n//     4   5   6\n//        /\n//       7\n\n// Output:\n// 7\n// Note: You may assume the tree (i.e., the given root node) is not NULL.\n// preorder traversal - first vist the most left child and traversal back - DFS\n// leve order traversal - collect all the level node vale and get the last row of frist child - not idea solution\n\nconst findBottomLeftValue = root => {\n    let result;\n    let maxHeight = 0;\n    const preorderTraversal = (node, level) => {\n        if (node === null) return node;\n        if (level > maxHeight) {\n            result = node.val;\n            maxHeight = level;\n        }\n        preorderTraversal(node.left, level + 1);\n        preorderTraversal(node.right, level + 1);\n    }\n    preorderTraversal(root, 1);\n    return result;\n}\n\nconst findBottomLeftValue2 = root => {\n    // sanity check\n    if (root === null) return [];\n    let result;\n    let queue = [root];\n    while(queue.length > 0) {\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(current);\n    }\n    return result[result.length - 1][0];\n}\n\nconsole.log(findBottomLeftValue2(null));\nconsole.log(findBottomLeftValue(null));"},function(n,e){n.exports="// You need to find the largest value in each row of a binary tree.\n\n// Example:\n// Input: \n//           1\n//          / \\\n//         3   2\n//        / \\   \\  \n//       5   3   9 \n\n// Output: [1, 3, 9]\n\n// level order traversal - BFS\n\nvar largestValues = function(root) {\n    // sanity check\n    if (root === null) return [];\n\n    let result = [];\n    let queue = [root];\n    while (queue.length > 0){\n        let size = queue.length;\n        let current = [];\n        for (let i = 0; i < size; i++) {\n            let head = queue.shift();\n            current.push(head.val);\n            if (head.left !== null) { queue.push(head.left); }\n            if (head.right !== null) { queue.push(head.right); }\n        }\n        result.push(Math.max(...current));\n    }\n    return result;\n}\nconsole.log(largestValues(null));"},function(n,e){n.exports="// Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:\n\n// The root is the maximum number in the array.\n// The left subtree is the maximum tree constructed from left part subarray divided by the maximum number.\n// The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.\n// Construct the maximum tree by the given array and output the root node of this tree.\n\n// Example 1:\n// Input: [3,2,1,6,0,5]\n// Output: return the tree root node representing the following tree:\n\n//       6\n//     /   \\\n//    3     5\n//     \\    / \n//      2  0   \n//        \\\n//         1\n\nconst findMaxIndex = (num, x, y) => {\n    \n}\nconst buildBT = (nums, start, end) => {\n    if (start <= end) return null;\n    let mIndex;\n    for (let i = start; i < end; i++) {\n\n    }\n}\nvar constructMaximumBinaryTree = function(nums) {\n    if (nums === null || nums.length === 0) return null;\n    return buildBT(nums, 0, nums.length - 1);\n};\n\nconsole.log(constructMaximumBinaryTree([3,2,1,6,0,5]));"},function(n,e){n.exports='// Example 1:\n// Input:\n//      1\n//     /\n//    2\n// Output:\n// [["", "1", ""],\n//  ["2", "", ""]]\n// Example 2:\n// Input:\n//      1\n//     / \\\n//    2   3\n//     \\\n//      4\n// Output:\n// [["", "", "", "1", "", "", ""],\n//  ["", "2", "", "", "", "3", ""],\n//  ["", "", "4", "", "", "", ""]]\n\n// 1.allocate empty array with "";\n// 2.DFS through the tree - preorder traversal\n// 3.calculate the position [mid] to fill node.val;\n/**\n * @param {TreeNode} root\n * @return {string[][]}\n */\nvar getTreeMaxHeight = (root) => {\n    if (root === null) return 0;\n    return Math.max(getTreeMaxHeight(root.left), getTreeMaxHeight(root.right)) + 1;\n}\n\nvar fill = (node, result, level, left, right) => {\n    // sanity checko\n    if (node === null) return;\n    let mid = Math.floor((left + right) / 2);\n    result[level - 1][mid] = node.val.toString();\n    \n    fill(node.left, result, level + 1, left, mid - 1);\n    fill(node.right, result, level + 1, mid + 1, right);\n}\n\nvar printTree = function(root) {\n    // sanity check\n    if (root === null) return root;\n    \n    // base logic\n    let result = [];\n    let maxHeight = getTreeMaxHeight(root);\n    let maxWidth = Math.pow(2, maxHeight) - 1;\n\n    for (let i = 0; i < maxHeight; i++) {\n        result.push(new Array(maxWidth).fill(\'\'));\n    }\n    \n    fill(root, result, 1, 0, maxWidth - 1);\n    return result;\n};\n\n\nconsole.log(printTree(null));'},function(n,e){n.exports="\n// Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\n// Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)\n\n// Example 1:\n\n// [[0,0,1,0,0,0,0,1,0,0,0,0,0],\n//  [0,0,0,0,0,0,0,1,1,1,0,0,0],\n//  [0,1,1,0,1,0,0,0,0,0,0,0,0],\n//  [0,1,0,0,1,1,0,0,1,0,1,0,0],\n//  [0,1,0,0,1,1,0,0,1,1,1,0,0],\n//  [0,0,0,0,0,0,0,0,0,0,1,0,0],\n//  [0,0,0,0,0,0,0,1,1,1,0,0,0],\n//  [0,0,0,0,0,0,0,1,1,0,0,0,0]]\n// Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.\n\nconst changeLandToWater = (grid, i, j, count) => {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] !== 1) { return 0; }\n    \n    if (grid[i][j] === 1) {\n        grid[i][j] = 0;\n        count = 0;\n        let dx = [0, 0, 1, -1];\n        let dy = [1, -1, 0, 0];\n        for (let k = 0; k < 4; k++) {\n            count += changeLandToWater(grid, i + dx[k], j + dy[k], count);\n        }\n    }\n    return count + 1;\n}\nvar maxAreaOfIsland = function(grid) {\n    let result = 0;\n    for (let x = 0; x < grid.length; x++) {\n        for (let y = 0; y < grid[0].length; y++) {\n            if (grid[x][y] === 1) {\n             result = Math.max(result, changeLandToWater(grid, x, y, 0));\n            }\n        }\n    }    \n    return result;\n};\n\nconst area = [[0,0,1,0,0,0,0,1,0,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,1,1,0,1,0,0,0,0,0,0,0,0],\n[0,1,0,0,1,1,0,0,1,0,1,0,0],\n[0,1,0,0,1,1,0,0,1,1,1,0,0],\n[0,0,0,0,0,0,0,0,0,0,1,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,0,0,0,0,0,0,1,1,0,0,0,0]];\n\nconsole.log(maxAreaOfIsland(area));"},function(n,e){n.exports="// Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.\n\n// For example, \n\n// Given the tree:\n//         4\n//        / \\\n//       2   7\n//      / \\\n//     1   3\n\n// And the value to search: 2\n// You should return this subtree:\n\n//       2     \n//      / \\   \n//     1   3\n// In the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL.\n\n// Note that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as [], not null.\n\nconst searchBST = (root, val) => {\n    if (root === null) return root;\n    if (root.val === val) { return root; }\n    else if (val < root.val && root.left !== null) { return searchBST(root.left, val); }\n    else if (val > root.val && root.right !== null) { return searchBST(root.right, val); }\n    else { return []; }\n}"},function(n,e){n.exports="// Given a binary tree, return the inorder traversal of its nodes' values.\n\n// Example:\n\n// Input: [1,null,2,3]\n//    1\n//     \\\n//      2\n//     /\n//    3\n\n// Output: [1,3,2]\n\nfunction TreeNode(val){\n    this.val = val;\n    this.left = null;\n    this.right = null;\n}\nvar inorderTraversal = function(root) {\n    let result = [];\n    const traversal = head => {\n        if (head === null) return head;\n        traversal(head.left);\n        result.push(head.val);\n        traversal(head.right);\n    }\n    traversal(root);\n    return result;\n}\n\nconst tn1 = new TreeNode(1);\nconst tn2 = new TreeNode(2);\nconst tn3 = new TreeNode(3);\nconst tn4 = new TreeNode(4);\nconst tn5 = new TreeNode(5);\n\ntn1.left = tn2;\ntn1.right = tn3;\ntn2.left = tn4;\ntn2.right = tn5;\n\n//       1\n//      / \\\n//     2   3\n//    / \\\n//   4   5\n\nconsole.log(inorderTraversal(tn1));\n\n// -- InOrder Traversal without recursion\n//\n// 1) Create an empty stack S.\n// 2) Initialize current node as root\n// 3) Push the current node to S and set current = current->left until current is NULL\n// 4) If current is NULL and stack is not empty then \n//      a) Pop the top item from stack.\n//      b) Print the popped item, set current = popped_item->right \n//      c) Go to step 3.\n// 5) If current is NULL and stack is empty then we are done.\n\nconst inorderTraversal2 = (root) => \n{\n    let stack = [];\n    let inorder =[];\n    while (true)\n    {\n        while (root != null)\n        {\n            stack.push(root);\n            root = root.left;\n        }\n        if (stack.length === 0) break;\n        root = stack.pop();\n        inorder.push(root.val);\n        root = root.right;\n    }\n    return inorder;\n}\n\nconsole.log(inorderTraversal2(tn1));"},function(n,e){n.exports="// Given a binary tree, determine if it is a valid binary search tree (BST).\n\n// Assume a BST is defined as follows:\n\n// The left subtree of a node contains only nodes with keys less than the node's key.\n// The right subtree of a node contains only nodes with keys greater than the node's key.\n// Both the left and right subtrees must also be binary search trees.\n// Example 1:\n\n// Input:\n//     2\n//    / \\\n//   1   3\n// Output: true\n// Example 2:\n\n//     5\n//    / \\\n//   1   4\n//      / \\\n//     3   6\n// Output: false\n// Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value\n//              is 5 but its right child's value is 4.\n\n// inorder traversal\nconst isValidBST = root => {\n    let result = [];\n    const traversal = head => {\n        if (head === null) return head;\n        traversal(head.left);\n        result.push(head.val);\n        traversal(head.right);\n    }\n    traversal(root);\n    \n    let slow = 0;\n    let fast = 1;\n    while (fast <= result.length - 1) {\n        if (result[slow] >= result[fast]) return false;\n        slow++;\n        fast++;\n    }\n    return true;\n}\n// ----------------------------------------------------------\nvar isValidBST2 = root => helper(root, null, null)\n\nvar helper = (root, min, max) => {\n  if (root === null) return true\n  if (min !== null && root.val <= min) return false\n  if (max !== null && root.val >= max) return false\n  return helper(root.left, min, root.val) && helper(root.right, root.val, max)\n}\n\nconsole.log(isValidBST(null));\nconsole.log(isValidBST2(null));"},function(n,e){n.exports='// // https://www.youtube.com/watch?v=vWPCm69MSfs\n\n// Given two words (beginWord and endWord), and a dictionary\'s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n\n// Only one letter can be changed at a time.\n// Each transformed word must exist in the word list. Note that beginWord is not a transformed word.\n\n// Input:\n// beginWord = "hit",\n// endWord = "cog",\n// wordList = ["hot","dot","dog","lot","log","cog"]\n\n// Output: 5\n\n// Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", return its length 5.\n// -----------\n\n// Example 2:\n// Input:\n// beginWord = "hit"\n// endWord = "cog"\n// wordList = ["hot","dot","dog","lot","log"]\n\n// Output: 0\n\n// Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.\n\n// function ladderLength(beginWord, endWord, wordList) {\n//     let len = 1;\n//     let result = [];\n//     let queue = [beginWord];\n//     const dict = new Set(wordList);\n//     const seen = new Set(queue);\n//     while (queue.length) {\n//       const next = [];\n//       for (let v of queue) {\n//         if (v === endWord) {\n//           console.log(result);\n//           return len;\n//         }\n        \n//         const arr = v.split(\'\');\n//         for (let i = 0; i < arr.length; i++) {\n//           for (let d = 0; d < 26; d++) {\n//             arr[i] = String.fromCharCode(97+d);\n//             const nv = arr.join(\'\');\n//             if (!seen.has(nv) && dict.has(nv)) {\n//               next.push(nv);\n//               seen.add(nv);\n//             }\n//             arr[i] = v[i];\n//           }\n//         }\n//         result.push(...next);\n//       }\n//       queue = next;\n//       len++;\n//     }\n    \n//     return 0;\n//   }\n\nconst swapLetterInWord = (string, index, replace) =>{\n  return string.substring(0, index) + replace + string.substring(index + 1);\n}\nconst ladderLength = (beginWord, endWorld, wordList) => {\n    wordList.splice(wordList.indexOf(beginWord), 1);\n    let level = 1;\n    let current = 1;\n    let next = 0;\n    let queue = [beginWord];\n    while(queue.length > 0) {\n      let word = queue.shift();\n      current--;\n      for (let i = 0; i < word.length; i++) {\n        for (let j = \'a\'.charCodeAt(0); j < \'z\'.charCodeAt(0); j++) {\n          let temp = swapLetterInWord(word, i, String.fromCharCode(j));\n          if (wordList.indexOf(temp) > -1) {\n            if (temp === endWorld) return level + 1;\n            next++;\n            queue.push(temp);\n            wordList.splice(wordList.indexOf(temp), 1);\n          }\n        }\n      }\n      if (current === 0) {\n        current = next;\n        next = 0;\n        level++;\n      }\n    }\n    return 0;\n}\nconsole.log(ladderLength("hit", "cog", ["hit","hot","dot","dog","lot","log","cog"]));'},function(n,e){n.exports='\n// You have a lock in front of you with 4 circular wheels. \n// Each wheel has 10 slots: \'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\'. The wheels can rotate freely and wrap around: for example we can turn \'9\' to be \'0\', or \'0\' to be \'9\'. Each move consists of turning one wheel one slot.\n\n// The lock initially starts at \'0000\', a string representing the state of the 4 wheels.\n\n// You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\n\n// Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n\n// Example 1:\n// Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"\n// Output: 6\n// Explanation:\n// A sequence of valid moves would be "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202".\n// Note that a sequence like "0000" -> "0001" -> "0002" -> "0102" -> "0202" would be invalid,\n// because the wheels of the lock become stuck after the display becomes the dead end "0102".\n// Example 2:\n// Input: deadends = ["8888"], target = "0009"\n// Output: 1\n// Explanation:\n// We can turn the last wheel in reverse to move from "0000" -> "0009".\n// Example 3:\n// Input: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"\n// Output: -1\n// Explanation:\n// We can\'t reach the target without getting stuck.\n// Example 4:\n// Input: deadends = ["0000"], target = "8888"\n// Output: -1\n// Note:\n// The length of deadends will be in the range [1, 500].\n// target will not be in the list deadends.\n// Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities \'0000\' to \'9999\'.\n\n/**\n * @param {string[]} deadends\n * @param {string} target\n * @return {number}\n */\n\nfunction setCharAt(str,index,chr) {\n    if(index > str.length-1) return str;\n    return str.substr(0,index) + chr + str.substr(index+1);\n}\n\n\n// const SKIP = \'SKIP\';\n// const DEFAULT = -1;\n\n// var openLock = function(deadends, target) {\n//     // sanity check\n//     let start = \'0000\';\n//     let counter = 0;\n//     let queue = [start];\n//     let visited = [start];\n//     let dead = {};\n//     for (let d = 0; d < deadends.length; d++) {\n//         dead[deadends[d]] = deadends[d];\n//     }\n\n//     while(queue.length > 0) {\n//         counter++;\n//         let size = queue.length;\n//         for (let i = 0; i < size; i++) {\n//             let combination = queue.pop();\n//             for (let j = 0; j < 4; j++) {\n//                 for(let k = -1; k <= 1; k = k + 2) {\n//                     let next = combination;\n//                     next = setCharAt(next, j,  (next[j] - \'0\' + k + 10) % 10);\n//                     if (next === target) return counter;\n//                     if (dead[next]) { console.log(dead[next]); }\n//                     if (visited[next] !== undefined) continue;\n//                     queue.push(next);\n//                     visited[next] = next;\n//                 }\n//             }\n//         }\n//     }\n\n//     return -1;\n// };\n\nconst SKIP = \'SKIP\';\nconst DEFAULT = -1;\n\nfunction openLock(deadends, target) {\n  const visited = deadends.reduce((result, key) => {\n    if (!result[key]) {\n      result[key] = SKIP;\n    }\n\n    return result;\n  }, {});\n\n  if (visited[\'0000\'] || visited[target]) {\n    return DEFAULT;\n  }\n\n  const queue = [\'0000\'];\n  visited[\'0000\'] = 0;\n\n  while (queue.length) {\n    const current = queue.shift();\n    const len = visited[current];\n\n    if (current === target) {\n      return len;\n    }\n\n    const nexts = getNexts(current);\n    console.log(nexts);\n    queue.push.apply(queue, nexts.filter((n) => {\n      if (!visited[n]) {\n        visited[n] = len + 1;\n        return true;\n      }\n    }));\n  }\n\n  return DEFAULT;\n}\n\nfunction getNexts(s) {\n  const result = [];\n  let sb = s;\n\n  for (let i = 0; i < s.length; i++) {\n    const c = parseInt(s[i]);\n    const cString = c.toString();\n    const a = c === 9 ? \'0\' : (c + 1).toString();\n    const b = c === 0 ? \'9\' : (c - 1).toString();\n    sb = replaceAt(sb, i, a);\n    result.push(sb);\n    sb = replaceAt(sb, i, b);\n    result.push(sb);\n    sb = replaceAt(sb, i, cString);\n  }\n\n  return result;\n}\n\nfunction replaceAt(string, index, replacement) {\n  const beginning = string.substring(0, index);\n  const end = string.substring(index + replacement.length);\n  return `${beginning}${replacement}${end}`;\n}\n\n\nconst deadends = ["0201","0101","0102","1212","2002"];\nconst target = "0202";\n\nconsole.log(openLock(deadends, target));\n'},function(n,e){n.exports='// Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\n\n// A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n\n\n// Example:\n\n// Input: "23"\n// Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n\n/**\n * @param {string} digits\n * @return {string[]}\n */\n\nconst helper = (letters, digits, startIndex, combination, result) => {\n    // sanity check\n    if (startIndex === digits.length) { result.push(combination.join(\'\')); return; }\n    \n    // core logic\n    for (let i = 0; i < letters[digits[startIndex]].length; i++){\n        const c = letters[digits[startIndex]][i];\n        combination.push(c);\n        helper(letters, digits, startIndex + 1 , combination, result);\n        combination.pop();\n    }\n}\nvar letterCombinations = function(digits) {\n    const letters = {\n        2: \'abc\',\n        3: \'def\',\n        4: \'ghi\',\n        5: \'jkl\',\n        6: \'mno\',\n        7: \'pqrs\',\n        8: \'tuv\',\n        9: \'wxyz\'\n    };\n    // sanity check\n    if (digits.length === 0) return [];\n        \n    // create empty array to store the combinations\n    let result = [];\n    \n    // base logice - recursive\n    helper(letters, digits, 0, [], result);\n\n    // return\n    return result;\n};\n\nconsole.log(letterCombinations("23"));\n\n'},function(n,e){n.exports="// Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\n\n// Note:\n\n// All numbers will be positive integers.\n// The solution set must not contain duplicate combinations.\n// Example 1:\n\n// Input: k = 3, n = 7\n// Output: [[1,2,4]]\n// Example 2:\n\n// Input: k = 3, n = 9\n// Output: [[1,2,6], [1,3,5], [2,3,4]]\n\n// k = the number of combinatation set [1,2,3] [3,4,1]\n// n = target number\n\nvar dfs = (nums, numSetSize, target, index, subset, result) => {\n    if (target < 0) return;\n    if (target === 0 && subset.length === numSetSize) { result.push(subset.slice()); return; }\n\n    for (let i = index; i < nums.length; i++) {\n        subset.push(nums[i]);\n        dfs(nums,numSetSize, target - nums[i], i + 1, subset, result);\n        subset.pop();\n    }\n}\nvar combinationSum3 = function(numSetSize, target) {\n    if (numSetSize === 0 || target === 0) { return []; }\n\n    let result = [];\n    dfs([1,2,3,4,5,6,7,8,9], numSetSize, target, 0, [], result);\n    return result;\n};\n\nconsole.log(combinationSum3(3,9));"},function(n,e){n.exports="// Problem:\n\n// Numbers can be regarded as product of its factors. For example, \n\n// 8 = 2 x 2 x 2;\n//   = 2 x 4.\n// Write a function that takes an integer n and return all possible combinations of its factors. \n\n// Note: \n\n// Each combination's factors must be sorted ascending, for example: The factors of 2 and 6 is [2, 6], not [6, 2]. \n// You may assume that n is always positive. \n// Factors should be greater than 1 and less than n.\n \n\n// Examples: \n// input: 1\n// output: \n\n// []\n// input: 37\n// output: \n\n// []\n// input: 12\n// output:\n\n// [\n//   [2, 6],\n//   [2, 2, 3],\n//   [3, 4]\n// ]\n// input: 32\n// output:\n\n// [\n//   [2, 16],\n//   [2, 2, 8],\n//   [2, 2, 2, 4],\n//   [2, 2, 2, 2, 2],\n//   [2, 4, 4],\n//   [4, 8]\n// ]\n\nconst dfs = (target, index, subset, result) => {\n    if (target === 1 && subset.length > 1) { result.push(subset.slice()); }\n\n    for (let i = index; i <= target; i++) {\n        if (target % i === 0) {\n            subset.push(i);\n            dfs(target/i, i, subset, result);\n            subset.pop();\n        }\n    }\n}\nconst getFactors = target => {\n    if (target === null || target === 0) return [];\n\n    const result = [];\n    dfs(target, 2, [], result);\n    return result;\n}\n\nconsole.log(getFactors(12));\n\n// ---------------------------------------------\n\nconst dfs2 = (target, index, subset, result) => {\n    if (target === 1 && subset.length > 1) {\n        result.push(subset.slice());\n    }\n    for (let i = index; i < target; i++) {\n        if (target % i === 0) {\n            subset.push(i);\n            dfs2(target / i, i, subset, result);\n            subset.pop();\n        }\n    }\n}\nconst getFactors2 = target => {\n    if (target === null || target === 0) return [];\n\n    let result = [];\n    dfs2(target, 2, [], result);\n    return result;\n}\n\nconsole.log(getFactors2(12));\n"},function(n,e){n.exports="// Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n// The same repeated number may be chosen from candidates unlimited number of times.\n\n// Note:\n\n// All numbers (including target) will be positive integers.\n// The solution set must not contain duplicate combinations.\n// Example 1:\n\n// Input: candidates = [2,3,6,7], target = 7,\n// A solution set is:\n// [\n//   [7],\n//   [2,2,3]\n// ]\n\nconst helper = (candidates, target, startIndex, combination, result) => {\n    // sanity check \n    if (target === 0) { result.push(combination.slice()) }\n    \n    for (let i = startIndex; i < candidates.length; i++) {\n        if (target < candidates[i]) break;\n        if (i !== 0 && candidates[i] === candidates[i - 1]) continue;\n        \n        combination.push(candidates[i]);\n        helper(candidates, target - candidates[i], i, combination, result);\n        combination.pop();\n    }\n}\n\nconst combinationSum = (candidates, target) => {\n    // sanity check\n    if (target === 0) return [];\n    if (candidates === null && candidates.length === 0) return [];\n    \n    // create result array\n    let result = [];\n    \n    // sort candidates\n    candidates.sort((a, b) => a - b);\n    \n    // call recursion\n    helper(candidates, target, 0, [], result);\n    return result;   \n}\n\nconsole.log(combinationSum([1,3,4], 4));\n// ----------------------------------------------\nconst dfs = (nums, target, index, subset, result) => {\n    if ( target < 0) return;\n    if ( target === 0) { result.push(subset.slice()); return;}\n    for (let i = index; i < nums.length; i++) {\n        subset.push(nums[i]);\n        dfs(nums, target - nums[i], i, subset, result);\n        subset.pop();\n    }\n}\n\nconst combinationSum2 = (nums, target) => {\n    if (nums === null || nums.length === 0 || target === 0) { return []; }\n    let result = [];\n    dfs(nums, target, 0, [], result);\n    return result;\n}\n\nconsole.log(combinationSum2([1,3,4], 4));\n"},function(n,e){n.exports="// Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n// Each number in candidates may only be used once in the combination.\n\n// Note:\n\n// All numbers (including target) will be positive integers.\n// The solution set must not contain duplicate combinations.\n// Example 1:\n\n// Input: candidates = [10,1,2,7,6,1,5], target = 8,\n// A solution set is:\n// [\n//   [1, 7],\n//   [1, 2, 5],\n//   [2, 6],\n//   [1, 1, 6]\n// ]\n\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nconst helper = (candidates, target, startIndex, combination, result) => {\n    // sanity check\n    if (target === 0) { result.push(combination.slice()); }\n\n    // core logic\n    for (let i = startIndex; i < candidates.length; i++) {\n        if (target < candidates[i]) break;\n        if (i !== startIndex && candidates[i] === candidates[i-1]) continue;\n        combination.push(candidates[i]);\n        helper(candidates, target - candidates[i], i + 1, combination, result);\n        combination.pop();\n    }\n}\n\nvar combinationSum = function(candidates, target) {\n    // sanity check\n    if (target === 0) return [];\n    if (candidates === null && candidates.length === 0) return [];\n\n    // create empty result array\n    let result = [];\n\n    // sort candidate\n    candidates.sort(( a, b) => a - b);\n\n    // basic logic recursion\n    helper(candidates, target, 0, [], result);\n    \n    // return\n    return result;\n};\n\nconsole.log(combinationSum([10,1,2,7,6,1,5],8));\n\n//----------------------------------------------\nconst dfs = (nums, target, index, subset, result) => {\n    if (target < 0) return;\n    if (target === 0) { result.push(subset.slice()); return; }\n\n    for (let i = index; i < nums.length; i++) {\n        if (i !== index && nums[i] === nums[i-1]) continue;\n        subset.push(nums[i]);\n        dfs(nums, target - nums[i], i + 1, subset, result);\n        subset.pop();\n    }\n}\nconst combinationSum2 = (nums, target) => {\n    //sanity check\n    if (nums === null || nums.length === 0 || target === 0) return [];\n\n    nums.sort((a,b) => a - b);\n    let result = [];\n    dfs(nums, target, 0, [], result);\n    return result;\n}\n\nconsole.log(combinationSum2([10,1,2,7,6,1,5],8));\n"},function(n,e){n.exports="// Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n\n// Example:\n\n// Input: n = 4, k = 2\n// Output:\n// [\n//   [2,4],\n//   [3,4],\n//   [2,3],\n//   [1,2],\n//   [1,3],\n//   [1,4],\n// ]\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {number[][]}\n */\n\nconst helper = (nums, target, startIndex, combination, result) => {\n    // sanity check\n    if (combination.length === target) { result.push(combination.slice()); }\n    // core logic \n    for (let i = startIndex; i < nums.length; i++) {\n        combination.push(nums[i]);\n        helper(nums, target, i + 1, combination, result) ;\n        combination.pop();\n    }\n}\n\nvar combine = function(n, k) {\n    // sanity check\n    if (n === 0 || k === 0) { return []}\n    \n    let result = [];\n    let nums = [];\n    for (let i = 1; i <= n; i++) { nums.push(i); }\n    \n    helper(nums, k, 0, [], result);\n    return result;\n};\n\nconst dataArray = 4;\nconst target = 2;\n\nconsole.log(combine(dataArray,target));\n\nconst dfs = (nums, target, start, combination, result) => {\n    //sanity check\n    if (combination.length === target) { result.push(combination.slice()); }\n\n    for (let i = start; i < nums.length; i++) {\n        combination.push(nums[i]);\n        dfs(nums, target, i + 1, combination, result);\n        combination.pop();\n    }\n}\n\nconst backtracking = (nums, target) => {\n    if (nums === null || target < 1) return [];\n    let result = [];\n    dfs(nums, target, 0, [], result);\n    return result;\n}\n\nconsole.log(backtracking([1,2,3,4], 3))\nconsole.log(backtracking(null, 0))"},function(n,e){n.exports="/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} newColor\n * @return {number[][]}\n */\n\nvar floodFill = function(image, sr, sc, newColor) {\n    helper(image, sr, sc, image[sr][sc], newColor);\n    return image;\n};\n\nconst helper = (image, sr, sc, originalColor, newColor) => {\n    if (sr < 0 || sr === image.length || sc < 0 || sc === image[sr].length || image[sr][sc] !== originalColor || image[sr][sc] === newColor) {\n        return;\n    }\n    image[sr][sc] = newColor;\n    helper(image, sr - 1, sc, originalColor, newColor);\n    helper(image, sr + 1, sc, originalColor, newColor);\n    helper(image, sr, sc - 1, originalColor, newColor);\n    helper(image, sr, sc + 1, originalColor, newColor);\n}\n\nconst image = [\n    [0,1,1,1],\n    [1,1,1,1],\n    [0,0,0,0],\n    [1,1,1,0],\n]\n\nconsole.log(floodFill(image,1,1,2));"},function(n,e){n.exports="// Given a tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.\n\n// Example 1:\n// Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]\n\n//        5\n//       / \\\n//     3    6\n//    / \\    \\\n//   2   4    8\n//  /        / \\ \n// 1        7   9\n\n// Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\nfunction TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\nvar increasingBST = function(root) {\n    let result = [];\n    const traversal = head => {\n        if (head === null) return head;\n        traversal(head.left);\n        result.push(head.val);\n        traversal(head.right);\n    }\n    traversal(root);\n    \n    let dummyTree = new TreeNode(0);\n    let current = dummyTree;\n    for (let i = 0; i < result.length; i++) {\n        current.right = new TreeNode(result[i]);\n        current = current.right;\n    }\n    return dummyTree.right;\n}\n\nconst n1 = new TreeNode(3);\nconst n2 = new TreeNode(9);\nconst n3 = new TreeNode(20);\nconst n4 = new TreeNode(15);\nconst n5 = new TreeNode(7);\n\nn1.left = n2;\nn1.right = n3;\nn3.left = n4;\nn3.right = n5;\n\nconsole.log(increasingBST(n1));"},function(n,e){n.exports="// You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\n// Example 1:\n\n// Input: coins = [1, 2, 5], amount = 11\n// Output: 3 \n// Explanation: 11 = 5 + 5 + 1\n\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    var dp=new Array(amount+1);\n    dp.fill(Number.MAX_VALUE-1);\n    dp[0]=0;\n    for(var i=1;i<=amount;i++)\n    {\n        for(var j=0;j<coins.length;j++) {\n            if(coins[j]<=i){\n                dp[i]=Math.min(dp[i-coins[j]]+1, dp[i]);\n            }\n        }\n    }\n   return dp[amount] === Number.MAX_VALUE-1 ? -1:dp[amount];  \n};\n\nconsole.log(coinChange(12));"},function(n,e){n.exports="// Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n\n// You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n// Example:\n\n// Given nums = [2, 7, 11, 15], target = 9,\n\n// Because nums[0] + nums[1] = 2 + 7 = 9,\n// return [0, 1].\n\nconst twoSum = (nums, target) => {\n    // sanity check\n    if (nums === null) { return []; }\n    let map = {};\n    for (let i = 0; i < nums.length; i++) {\n        let current = nums[i];\n        let counter = target - current;\n        if (map[current] === undefined) {\n            map[counter] = i;\n        } else {\n            return [map[current], i];\n        }\n    }\n}\nconsole.log(twoSum([2, 7, 11, 15],9));"},function(n,e){n.exports="// Given an array of integers, find if the array contains any duplicates.\n\n// Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\n// Example 1:\n\n// Input: [1,2,3,1]\n// Output: true\n// Example 2:\n\n// Input: [1,2,3,4]\n// Output: false\n// Example 3:\n\n// Input: [1,1,1,3,3,4,3,2,4,2]\n// Output: true\n\nconst containsDuplicate = nums => {\n    let map = {};\n    for (let i = 0; i < nums.length; i++) {\n        let current = nums[i];\n        if(map[current] === undefined) {\n            map[current] = true;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\nconsole.log(containsDuplicate(null));"},function(n,e){n.exports='// Given a string, find the length of the longest substring without repeating characters.\n\n// Example 1:\n\n// Input: "abcabcbb"\n// Output: 3 \n// Explanation: The answer is "abc", with the length of 3. \n// Example 2:\n\n// Input: "bbbbb"\n// Output: 1\n// Explanation: The answer is "b", with the length of 1.\n// Example 3:\n\n// Input: "pwwkew"\n// Output: 3\n// Explanation: The answer is "wke", with the length of 3. \n//              Note that the answer must be a substring, "pwke" is a subsequence and not a substring.\n\n/**\n * @param {string} s\n * @return {number}\n */\n\n// time complexity O(n)\nvar lengthOfLongestSubstring = function(s) {\n   let lookup = {};\n   let start = 0;\n   let max = 0;\n   for (let i = 0 ; i < s.length; i++) {\n       if (lookup[s[i]] !== undefined && lookup[s[i]] >= start) {\n           start = lookup[s[i]] + 1;\n       }\n\n       lookup[s[i]] = i;\n       max = Math.max(max, i - start + 1);\n   }\n   return max;\n};\n\n\nconsole.log(lengthOfLongestSubstring(\'pwwkew\'));\nconsole.log(lengthOfLongestSubstring(\'abba\'));\nconsole.log(lengthOfLongestSubstring(\'raceracecar\'));\nconsole.log(lengthOfLongestSubstring(\'obamacare\'));'},function(n,e){n.exports='// A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.\n\n// Now given an M x N matrix, return True if and only if the matrix is Toeplitz.\n \n\n// Example 1:\n\n// Input:\n// matrix = [\n//   [1,2,3,4],\n//   [5,1,2,3],\n//   [9,5,1,2]\n// ]\n// Output: True\n// Explanation:\n// In the above grid, the diagonals are:\n// "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]".\n// In each diagonal all elements are the same, so the answer is True.\n\nconst isToeplitzMatrix = matrix => {\n    for (let i = 0; i < matrix.length - 1; i++) {\n        for(let j = 0; j < matrix[0].length - 1; j++) {\n           if (matrix[i][j] !== matrix[i+1][j+1]) return false;\n        }\n    }\n    return true;\n}\nconsole.log(isToeplitzMatrix(null));'},function(n,e){n.exports='// You\'re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.\n\n// The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".\n\n// Example 1:\n\n// Input: J = "aA", S = "aAAbbbb"\n// Output: 3\n// Example 2:\n\n// Input: J = "z", S = "ZZ"\n// Output: 0\n\nconst numJewelsInStones = (jStone, sStone ) => {\n    let result = 0;\n    let map = {};\n    for (let j = 0; j < jStone.length; j++) {\n        map[jStone[j]] = true;\n    }\n\n    for (let s = 0; s < sStone.length; s++) {\n        if (map[sStone[s]]) { result++; }\n    }\n    return result;\n}\nconsole.log(numJewelsInStones(null,null));\n\nconst numJewelsInStones2 = (jStone, sStone ) => {\n    let result = 0;\n    for (let i = 0; i < sStone.length; i++) {\n        if (jStone.indexOf(sStone[i]) >= 0) {\n            result++;\n        }\n    }\n    return result;\n}\n\nconsole.log(numJewelsInStones2([\'aB\'],[\'aaBBBBaa\']));'},function(n,e){n.exports='// International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: "a" maps to ".-", "b" maps to "-...", "c" maps to "-.-.", and so on.\n\n// For convenience, the full table for the 26 letters of the English alphabet is given below:\n\n// [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]\n// Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, "cab" can be written as "-.-.-....-", (which is the concatenation "-.-." + "-..." + ".-"). We\'ll call such a concatenation, the transformation of a word.\n\n// Return the number of different transformations among all words we have.\n\n// Example:\n// Input: words = ["gin", "zen", "gig", "msg"]\n// Output: 2\n// Explanation: \n// The transformation of each word is:\n// "gin" -> "--...-."\n// "zen" -> "--...-."\n// "gig" -> "--...--."\n// "msg" -> "--...--."\n\n// There are 2 different transformations, "--...-." and "--...--.".\n\nvar uniqueMorseRepresentations = function(words) {\n    let morseCodeLookup = [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."];\n    let translatedWords = [];\n    words.forEach(word => {\n        let wordSplit = word.split(\'\');\n        let compiledWord = \'\';\n        wordSplit.forEach((character, idx) => {\n            compiledWord += morseCodeLookup[word.charCodeAt(idx) - 97];\n        })\n        translatedWords.push(compiledWord);\n    });\n    \n    let filteredWords = [];\n    translatedWords.forEach(word => {\n        if(!filteredWords.includes(word)) filteredWords.push(word);\n    })\n    return filteredWords.length;\n};\n\nconsole.log(uniqueMorseRepresentations(\'\'));'},function(n,e){n.exports="// Given a binary tree\n\n// struct TreeLinkNode {\n//   TreeLinkNode *left;\n//   TreeLinkNode *right;\n//   TreeLinkNode *next;\n// }\n// Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\n// Initially, all next pointers are set to NULL.\n\n// Note:\n\n// You may only use constant extra space.\n// Recursive approach is fine, implicit stack space does not count as extra space for this problem.\n// You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).\n// Example:\n\n// Given the following perfect binary tree,\n\n//      1\n//    /  \\\n//   2    3\n//  / \\  / \\\n// 4  5  6  7\n// After calling your function, the tree should look like:\n\n//      1 -> NULL\n//    /  \\\n//   2 -> 3 -> NULL\n//  / \\  / \\\n// 4->5->6->7 -> NULL\n\nconst connect = node => {\n    // sanity check\n    if (node === null) return;\n    if (node.left !== null) {\n        node.left.next = node.right;\n    }\n    if (node.next !== null && node.right !== null) {\n        node.right.next = node.next.left;\n    }\n    connect(node.left);\n    connect(node.right);\n}"},function(n,e){n.exports="// Given a linked list, determine if it has a cycle in it.\n\n// Follow up:\n// Can you solve it without using extra space?\n\nconst hasCycle = head => {\n    if (head === null) return false;\n    let slow = head;\n    let fast = head;\n    while(fast.next !== null && fast.next.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) return true;\n    }\n    return false;\n}\n\nconsole.log(hasCycle(null));"},function(n,e){n.exports="// Sort a linked list in O(n log n) time using constant space complexity.\n\n// Example 1:\n\n// Input: 4->2->1->3\n// Output: 1->2->3->4\n// Example 2:\n\n// Input: -1->5->3->4->0\n// Output: -1->0->3->4->5\n \n// const ListNode = (val) => {\n//     this.val = val;\n//     this.next = null;\n// }\nfunction ListNode(val) {\n    this.val = val;\n    this.next = null; \n}\nconst mergeTwoLists = (list1, list2) => {\n    let mergeTwoList = new ListNode(0);\n    let current = mergeTwoList;\n    while(list1 !== null && list2 !== null) {\n        if (list1.val <= list2.val) {\n            current.next = list1;\n            list1 = list1.next;\n        } else {\n            current.next = list2;\n            list2 = list2.next;\n        }\n        current = current.next;\n    }\n    if (list1 === null) { current.next = list2; }\n    if (list2 === null) { current.next = list1; }\n    return mergeTwoList.next;\n}\nconst sortList = head => {\n    if (head === null || head.next === null) return head;\n    let pre = head, slow = head, fast = head;\n    while(fast !== null && fast.next !== null) {\n        pre = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    pre.next = null;\n    return mergeTwoLists(sortList(head), sortList(slow))\n}\n\nconst n1 = new ListNode(1);\nconst n2 = new ListNode(12);\nconst n3 = new ListNode(3);\nconst n4 = new ListNode(24);\nconst n5 = new ListNode(5);\nconst n6 = new ListNode(36);\nconst n7 = new ListNode(7);\n\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\nn4.next = n5;\nn5.next = n6;\nn6.next = n7;\n\nconsole.log(n1);\n\nconsole.log(sortList(n1));"},function(n,e){n.exports="// Given a linked list, remove the n-th node from the end of list and return its head.\n\n// Example:\n\n// Given linked list: 1->2->3->4->5, and n = 2.\n\n// After removing the second node from the end, the linked list becomes 1->2->3->5.\nconst ListNode = val => {\n    this.val = val;\n    this.next = null;\n}\nconst removeNthFromEnd = (head, n) => {\n    if (head === null && n === 0) return head;\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let slow = dummyNode;\n    let fast = dummyNode;\n\n    for (let i = 0; i < n; i++) {\n        fast = fast.next;\n    }\n\n    while(fast.next) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    slow.next = slow.next.next;\n    return dummyNode.next;\n}\n\nconsole.log(removeNthFromEnd(new ListNode(0), 1));"},function(n,e){n.exports="// You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\n// You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n// Example:\n\n// Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n// Output: 7 -> 0 -> 8\n// Explanation: 342 + 465 = 807.\n\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nconst ListNode = val => {\n    this.val = val;\n    this.next = null;\n};\nvar addTwoNumbers = function(l1, l2) {\n    let twoSum = new ListNode(0);\n    let cur = twoSum;\n    let carryOver = 0;\n    while(l1 || l2) {\n       let val1 = l1 && l1.val !== null ? l1.val : 0;\n       let val2 = l2 && l2.val !== null ? l2.val : 0;\n       let sum = val1 + val2 + carryOver;\n       if (sum >= 10) {\n          cur.next = new ListNode(sum % 10);\n          carryOver = Math.floor(sum / 10);\n       } else {\n          cur.next = new ListNode(sum);\n          carryOver = 0;\n       }\n       cur = cur.next;\n       l1 = l1 && l1.next;\n       l2 = l2 && l2.next;\n    }\n    if (carryOver > 0) {\n        cur.next = new ListNode(carryOver);\n    }\n    return twoSum.next;\n  };\n\n  console.log(addTwoNumbers(null, null));"},function(n,e){n.exports="// Remove all elements from a linked list of integers that have value val.\n\n// Example:\n\n// Input:  1->2->6->3->4->5->6, val = 6\n// Output: 1->2->3->4->5\n\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\nconst ListNode = (val) => {\n    this.val = val;\n    this.next = null;\n}\nvar removeElements = (head, val) => {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    head = dummyNode;\n    while(head.next !== null) {\n        if (head.next.val === val) {\n            head.next = head.next.next;\n        } else {\n            head = head.next;\n        }\n    }\n    return dummyNode.next\n}\nconsole.log(removeElements(null,null));"},function(n,e){n.exports=" // Reverse a singly linked list.\n\n// Example:\n\n// Input: 1->2->3->4->5->NULL\n// Output: 5->4->3->2->1->NULL\n\nconst reverseList = head => {\n    if (head === null) return head;\n    let firstNode = head;\n    let currentNode = head.next;\n    while(currentNode) {\n        head.next = currentNode.next;\n        currentNode.next = firstNode;\n        firstNode = currentNode\n        currentNode = head.next;\n    }\n    return firstNode;\n}\n// console.log(reverseList(null));\n\nfunction Node(val) {\n    this.val = val;\n    this.next = null;\n}\n\nconst n1 = new Node(1);\nconst n2 = new Node(2);\nconst n3 = new Node(3);\nconst n4 = new Node(4);\nconst n5 = new Node(5);\nconst n6 = new Node(6);\nconst n7 = new Node(7);\n\nn1.next = n2;\nn2.next = n3;\nn3.next = n4;\nn4.next = n5;\nn5.next = n6;\nn6.next = n7;\n\n\nvar splitListToParts = function (root, k) {\n    // Result of K elements, containing the heads of each chunk\n    const chunks = new Array(k).fill(null);\n\n    // Find the length of the linked list, we need to know this\n    // to find the chunk size \n    let length = 0;\n\n    // Enumerate each node in the linked list until there are none\n    for (let node = root; node != null; node = node.next) {\n        length++;\n    }\n\n    // Calculate a chunk size for each k part\n    const chunkSize = length / k | 0;\n\n    // Calculate how much excess has to be distributed to the first\n    // n (remainder size) parts\n    let chunkRemainder = length % k;\n\n    // Enumerate from the root...\n    let current = root;\n\n    for (let insertIdx = 0; insertIdx < k && current != null; insertIdx++) {\n        // Store the current node as the head of the chunk \n        chunks[insertIdx] = current;\n\n        // Track the tail of *this* chunk\n        let chunkTail = current;\n\n        // Calculate the size of *this* chunk, which is the default chunk size\n        // +1 if there is still remainder to be distrubted \n        const size = chunkSize + (chunkRemainder-- > 0 ? 1 : 0);\n\n        // Collect all the next nodes for the appropriate chunk size \n        for (let i = 0; i < size; i++) {\n            chunkTail = current;\n            current = current.next;\n        }\n\n        // Clear the next pointer of the tail of the current chunk so \n        // the chunk terminates in null. \n        chunkTail.next = null;\n    }\n\n    return chunks;\n};\n\nconsole.log(splitListToParts(n1, 5));"},function(n,e){n.exports="// Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n\n// Example:\n\n// Input: 1->2->4, 1->3->4\n// Output: 1->1->2->3->4->4\n\nconst ListNode = val => {\n    this.val = val;\n    this.next = null;\n}\nconst mergeTwoLists = (list1, list2) => {\n    let mergedList = new ListNode(0);\n    let prev = mergedList;\n    while(list1 !== null && list2 !== null) {\n        if (list1.val <= list2.val) {\n            prev.next = list1;\n            list1 = list1.next;\n        } else {\n            prev.next = list2;\n            list2 = list2.next;\n        }\n        prev = prev.next;\n    }\n    if (list1 === null) { prev.next = list2; }\n    if (list2 === null) { prev.next = list1;}\n    return mergedList.next;\n}\nconsole.log(mergeTwoLists(null,null));"},function(n,e){n.exports="// Given a singly linked list, determine if it is a palindrome.\n\n// Example 1:\n\n// Input: 1->2\n// Output: false\n// Example 2:\n\n// Input: 1->2->2->1\n// Output: true\n// Follow up:\n// Could you do it in O(n) time and O(1) space?\n\nconst reverseList = head => {\n    if (head === null) return head;\n    let firstNode = head;\n    let currentNode = head.next;\n    while (currentNode) {\n        head.next = currentNode.next;\n        currentNode.next = firstNode;\n        firstNode = currentNode;\n        currentNode = head.next;\n    }\n    return firstNode;\n}\nconst isPalindrome = head =>{\n    if (head === null || head.next === null) return true;\n    let slow = head;\n    let fast = head;\n    while (fast.next !== null && fast.next.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    slow.next = reverseList(slow.next);\n    slow = slow.next;\n    \n    while (slow != null) {\n        if (slow.val !== head.val) return false;\n        slow = slow.next;\n        head = head.next;\n    }\n    return true;\n}\n\nconsole.log(isPalindrome(null));\n"},function(n,e){n.exports="// Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.\n\n// Given linked list -- head = [4,5,1,9], which looks like following:\n\n//     4 -> 5 -> 1 -> 9\n// Example 1:\n\n// Input: head = [4,5,1,9], node = 5\n// Output: [4,1,9]\n// Explanation: You are given the second node with value 5, the linked list\n//              should become 4 -> 1 -> 9 after calling your function.\n\nconst deleteNode = node => {\n    node.next = node.next.next;\n    node.val = node.next.val;\n}\nconsole.log(deleteNode(null));"},function(n,e){n.exports="// Given a sorted linked list, delete all duplicates such that each element appear only once.\n\n// Example 1:\n\n// Input: 1->1->2\n// Output: 1->2\n// Example 2:\n\n// Input: 1->1->2->3->3\n// Output: 1->2->3\n\nconst deleteDuplicates = head => { \n    if (head === null) { return head; }\n    let current = head;\n    while (current) {\n        if(current.next && current.next.val === current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\nconsole.log(deleteDuplicates(null));"},function(n,e){n.exports="// Given a non-empty, singly linked list with head node head, return a middle node of linked list.\n\n// If there are two middle nodes, return the second middle node.\n\n// Example 1:\n\n// Input: [1,2,3,4,5]\n// Output: Node 3 from this list (Serialization: [3,4,5])\n// The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).\n// Note that we returned a ListNode object ans, such that:\n// ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\n\nvar middleNode = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};\n\nconsole.log(middleNode(null));"},function(n,e){n.exports='// Given a string s, partition s such that every substring of the partition is a palindrome.\n\n// Return all possible palindrome partitioning of s.\n\n// Example:\n\n// Input: "aab"\n// Output:\n// [\n//   ["aa","b"],\n//   ["a","a","b"]\n// ]\n\n/**\n * @param {string} s\n * @return {string[][]}\n */\n\nconst isPalidrome = str => {\n    let start = 0;\n    let end = str.length - 1;\n    while ( start <= end) {\n        if (str[start] !== str[end]) { return false}\n        start++;\n        end--;\n    }\n    return true;\n}\nconst helper = (str, startIndex, partition, result) => {\n    // sanity check\n    if (startIndex === str.length) {\n        result.push(partition.slice());\n        return;\n    }\n    // core logic\n    for (let i = startIndex; i < str.length; i++) {\n        let subStr = str.slice(startIndex, i + 1);\n        if (!isPalidrome(subStr)) {\n            continue;\n        }\n\n        partition.push(subStr);\n        helper(str, i + 1, partition, result);\n        partition.pop();\n    }\n}\n\nconst partition = (str) => {\n    // sanity check\n    if (str === null || str.length === 0) return [];\n  \n    // create result array\n    let result = [];\n\n    // base logic - recursive\n    helper(str, 0, [], result);\n\n    // return\n    return result;\n};\n\nconsole.log(partition(\'aab\'));'},function(n,e){n.exports="// Permutation \n//    1. order does matter\n//    2. all the possible order\n\n// Given a collection of distinct integers, return all possible permutations.\n\n// Example:\n\n// Input: [1,2,3]\n// Output:\n// [\n//   [1,2,3],\n//   [1,3,2],\n//   [2,1,3],\n//   [2,3,1],\n//   [3,1,2],\n//   [3,2,1]\n// ]\n\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst helper = (nums, list, result) => {\n    // sanity check\n    if (list.length === nums.length) { console.log(list.slice());  result.push(list.slice()); }\n\n    // core logic\n    for (let i = 0; i < nums.length; i++) {\n        if (list.includes(nums[i])) { continue; } // if the number already include in the subset then dont push to list again\n        list.push(nums[i]);\n        helper(nums, list, result );\n        list.pop();\n    }\n}\nconst permute = nums => {\n    // sanity check\n    if (nums === null || nums.length === 0) return [];\n\n    // create an empty result array\n    let result = [];\n\n    // base logic\n    helper(nums, [], result);\n    \n    // return\n    return result;\n};\n\nconsole.log(permute([1,2,3]));\n"},function(n,e){n.exports="// Given a collection of numbers that might contain duplicates, \n// return all possible unique permutations.\n\n// Example:\n\n// Input: [1,1,2]\n// Output:\n// [\n//   [1,1,2],\n//   [1,2,1],\n//   [2,1,1]\n// ]\n\nfunction dfs(nums, current, visited, result) {\n  if(current.length === nums.length) {\n      result.push(current);\n      return;\n  }\n  for (let i = 0; i < nums.length; i++) {\n      if (visited[i] || (i > 0 && nums[i] === nums[i-1] && !visited[i-1])){\n          continue;\n      }\n      visited[i] = true; \n      dfs(nums, current.concat(nums[i]), visited, result);\n      visited[i] = false;\n  }\n}\n\nvar permuteUnique = function(nums) {\n  let result = [];\n  let visited = new Array(nums.length).fill(false);\n  nums.sort((a, b) => a - b);\n  dfs(nums, [], visited, result);\n  return result;\n};\n\nconsole.log(permuteUnique([1,2,3]));"},function(n,e){n.exports='// The set [1,2,3,...,n] contains a total of n! unique permutations.\n\n// By listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n// "123"\n// "132"\n// "213"\n// "231"\n// "312"\n// "321"\n// Given n and k, return the kth permutation sequence.\n\n// Note:\n\n// Given n will be between 1 and 9 inclusive.\n// Given k will be between 1 and n! inclusive.\n// Example 1:\n\n// Input: n = 3, k = 3\n// Output: "213"\n// Example 2:\n\n// Input: n = 4, k = 9\n// Output: "2314"\n\n/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\nconst dfs = (nums, list, result) => {\n    // sanity check\n    if (list.length === nums.length) { result.push(list.join(\'\')); }\n\n    // core logic\n    for (let i = 0; i < nums.length; i++) {\n        if (list.includes(nums[i])) { continue; }\n        list.push(nums[i]);\n        dfs(nums, list, result );\n        list.pop();\n    }\n}\n\nvar getPermutation = function(n, k) {\n    // sanity check\n    if (n === 0 || k === 0) return [];\n    \n    let result = [];\n    let uniquePermutation = [];\n    for (let i = 1; i <= n; i++) {\n        uniquePermutation.push(i);\n    }\n    \n    dfs(uniquePermutation, [], result);\n    \n    return result[k - 1];\n};\n\nconsole.log(getPermutation(3,3));\nconsole.log(getPermutation(4,9));'},function(n,e){n.exports="// Given a string containing only digits, restore it by returning all possible valid IP address combinations.\n\n// Example:\n\n// Input: \"25525511135\"\n// Output: [\"255.255.11.135\", \"255.255.111.35\"]\n\n/**\n * @param {string} s\n * @return {string[]}\n */\n\n// function restoreIpAddresses2(s) {\n//     const res = [];\n//     dfs([], 0);\n//     return res;\n    \n//     function dfs(prefix, idx) {\n//       if (prefix.length === 4 && idx === s.length) {\n//         res.push(prefix.join('.'));\n//         return;\n//       }\n      \n//       if (prefix.length === 4 || idx === s.length) {\n//         return;\n//       }\n      \n//       for (let r = idx; r < s.length; r++) {\n//         if (r !== idx && s[idx] === '0') return;\n        \n//         const num = parseInt(s.slice(idx, r+1));\n//         if (num > 255) {\n//           return;\n//         }\n//         prefix.push(num);\n//         dfs(prefix, r+1);\n//         prefix.pop();\n//       }\n//     }\n//   }\n\n\nconst dfs = (str, idx, combinations, res) => {\n    // once the combination contains 4 sets and index of string is at the end \n    // push the combination to result \n    if (combinations.length === 4 && idx === str.length) {\n      res.push(combinations.join('.'));\n      return;\n    }\n    \n    if (combinations.length === 4 || idx === str.length) return;\n    \n    for (let i = idx; i < str.length; i++) {\n      // a combination set should be less than 255\n      const num = parseInt(str.slice(idx, i+1));\n      if (i !== idx && str[idx] === '0') return;\n      if (num > 255) return;\n\n      combinations.push(num);\n      dfs(str, i+1, combinations, res);\n      combinations.pop();\n    }\n}\nvar restoreIpAddresses = function(str) {\n    // sanity check\n    if (str === null || str.length === 0) { return []}\n\n    // create empty array to store result\n    let result = [];\n\n    // base logic - recursion\n    dfs(str, 0, [], result);\n\n    // result\n    return result;\n};\n\nconsole.log(restoreIpAddresses('25525511135'));"},function(n,e){n.exports="// Given n non-negative integers a1, a2, ..., an , \n// where each represents a point at coordinate (i, ai).\n// n vertical lines are drawn such that the two endpoints \n// of line i is at (i, ai) and (i, 0). Find two lines, which \n// together with x-axis forms a container, such that the \n// container contains the most water.\n\n// Note: You may not slant the container and n is at least 2.\n\n/**\n * @param {number[]} height\n * @return {number}\n */\n\nconst findSizeContainer = (left, right , range) => {\n    return Math.min(left, right) * range;\n}\nvar maxArea = function(height) {\n    let max = 0;\n    let start = 0;\n    let end = height.length - 1;\n    \n    while (start < end) {\n        let newArea = findSizeContainer(height[start], height[end], end - start);\n        if (max < newArea) { max = newArea; }\n        \n        if (height[end] - height[start] > 0) {\n            start ++\n        } else {\n            end --;\n        }\n    }\n    return max\n};\n\nconsole.log(maxArea([1,8,6,2,5,4,8,3,7]));"},function(n,e){n.exports="// Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\n// Note:\n\n// The solution set must not contain duplicate triplets.\n\n// Example:\n\n// Given array nums = [-1, 0, 1, 2, -1, -4],\n\n// A solution set is:\n// [\n//   [-1, 0, 1],\n//   [-1, -1, 2]\n// ]\n\n// const twoSum = (nums, leftpointer, rightpointer, target, reuslt) => {\n//   while(leftpointer < rightpointer) {\n//     if (nums[leftpointer] + nums[rightpointer] === target) {\n//       reuslt.push([nums[leftpointer], nums[rightpointer], -target]);\n//       console.log(nums, leftpointer, rightpointer, target, reuslt);\n//       leftpointer++;\n//       rightpointer--;\n//     } else if (nums[leftpointer] + nums[rightpointer] < target) {\n//       leftpointer++;\n//     } else {\n//       rightpointer--;\n//     }\n//   }\n\n// }\n\n\n\nconst twoSum = (nums, target, result) => {\n  let start = 0;\n  let end = nums.length - 1;\n  while (start < end) {\n      let sum = nums[start] + nums[end];\n      if(sum === target) { result.push([nums[start], nums[end] , -target]); return [start + 1,end + 1] }\n      else if (sum < target) {\n          start++;\n      } else {\n          end--;\n      }\n  }\n  return null;\n}\nvar threeSum = function(nums) {\n    let result = [];\n    nums.sort((a, b) =>  a - b );\n    for (let i = 0; i < nums.length - 1; i++) {\n      if (i > 0 && nums[i] === nums[i - 1]) {\n          continue;\n      }\n        twoSum(nums, -nums[i], result)\n    }\n    return result;\n};\n\nconsole.log(threeSum([-1, 0, 1, 2, -1, -4]));"},function(n,e){n.exports="// Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\n\n// The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\n\n// Note:\n\n// Your returned answers (both index1 and index2) are not zero-based.\n// You may assume that each input would have exactly one solution and you may not use the same element twice.\n// Example:\n\n// Input: numbers = [2,7,11,15], target = 9\n// Output: [1,2]\n// Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.\n\nconst twoSum = (nums, target) => {\n    let start = 0;\n    let end = nums.length - 1;\n    while (start < end) {\n        let sum = nums[start] + nums[end];\n        if(sum === target) { return [start + 1,end + 1] }\n        else if (sum < target) {\n            start++;\n        } else {\n            end--;\n        }\n    }\n    return null;\n}\n\nconsole.log(twoSum(null));"},function(n,e){n.exports="// Say you have an array for which the ith element is the price of a given stock on day i.\n\n// Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\n// Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\n// Example 1:\n\n// Input: [7,1,5,3,6,4]\n// Output: 7\n// Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\n//              Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\n\nvar maxProfit = price => {\n    let res = 0;\n    let cur = price[0];\n    for (let i = 1; i < price.length; i++) {\n        if (price[i] > cur) {\n            res += price[i] - cur;\n        }\n        cur = price[i];\n    }\n    return res;\n}\nconsole.log(maxProfit(''));"},function(n,e){n.exports="// Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\n\n// Note: For the purpose of this problem, we define empty string as valid palindrome.\n\n// Example 1:\n\n// Input: \"A man, a plan, a canal: Panama\"\n// Output: true\n// Example 2:\n\n// Input: \"race a car\"\n// Output: false\n\nconst isPalindrome = str => {\n    const tempStr = str.replace(/[^\\w]/g, '').toLowerCase();\n    let left = 0;\n    let right = tempStr.length - 1;\n    while (left < right) {\n        if (tempStr[left] !== tempStr[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\nconsole.log(isPalindrome(''));"},function(n,e){n.exports='// Write a function that takes a string as input and returns the string reversed.\n\n// Example 1:\n\n// Input: "hello"\n// Output: "olleh"\n// Example 2:\n\n// Input: "A man, a plan, a canal: Panama"\n// Output: "amanaP :lanac a ,nalp a ,nam A"\n\nvar reverseString = function(s) {\n    var newString = \'\';\n    for (let i = s.length - 1; i >= 0 ; i --) {\n        newString += s[i];\n    }\n    return newString;\n};\n\nconsole.log(reverseString(\'123\'));'},function(n,e){n.exports='// Given a 32-bit signed integer, reverse digits of an integer.\n\n// Example 1:\n// Input: 123\n// Output: 321\n\n// Example 2:\n// Input: -123\n// Output: -321\n\n// Example 3:\n// Input: 120\n// Output: 21\n\nconst reverse = number => {\n    let y = Math.abs(number);\n    if(y.toString(2).length > 31) return 0;\n    let arr = y.toString().split("").reverse();\n    if(Number(arr.join("")).toString(2).length > 31) return 0;\n    let z = Number(arr.join(""));\n    return number >= 0 ? z : -z;\n}\n\nconsole.log(reverse(123));'},function(n,e){n.exports="// t: O(log n);  // O(log n) > O(n)\n// s: Constant\n\n// // O(n^2) \n// for () {\n//     for() {}\n// }\n\n// time complexity\n// o(1)\n// // if \n// //  sort o(log n)\n//     // binary search\n// // linear o(n)\n//     for()\n\n// // o (n * log n)\n//    for ()\n//         sort\n\n// // log (n^2)\n//     for (\n//         for ()\n//     )\n// // for ()   // o(n^3)\n//         for (\n//                 for()\n//         )\n\n    \n\n// s: O(2n) > o(n) \n\n// space (memory space):\n//     // lineear o(n)\n//     let test = [] > o(n) \n//     // space: constant\n//     let test = 1 > o(1)\n//     let test2 = 2 > o(2) // constant"},function(n,e){n.exports='const data = [  \n    {  \n       "date":"2018-01-29",\n       "category":"apple",\n       "count":"1"\n    },\n    {  \n       "date":"2018-01-29",\n       "category":"apple",\n       "count":"1"\n    },\n    {  \n       "date":"2018-01-28",\n       "category":"apple",\n       "count":"2"\n    },\n    {  \n       "date":"2018-01-27",\n       "category":"apple",\n       "count":"1"\n    },\n    {  \n       "date":"2018-01-29",\n       "category":"banana",\n       "count":"2"\n    },\n    {  \n       "date":"2018-01-27",\n       "category":"banana",\n       "count":"3"\n    },\n    {  \n       "date":"2018-01-27",\n       "category":"banana",\n       "count":"2"\n    },\n    {  \n       "date":"2018-01-28",\n       "category":"orange",\n       "count":"1"\n    },\n    {  \n       "date":"2018-01-29",\n       "category":"orange",\n       "count":"4"\n    },\n    {  \n       "date":"2018-01-24",\n       "category":"orange",\n       "count":"5"\n    }\n ];\n\n\n const groupCategory = () => {\n  let result = {};\n  for (let i = 0; i < data.length; i++) {\n    if (result[data[i].category] === undefined) {\n      result[data[i].category] = [ {date: data[i].date, count: data[i].count} ]\n    } else {\n      let temp = result[data[i].category];\n      let match = false;\n      for (let j = 0; j < temp.length; j++) {\n          if (temp[j].date === data[i].date) {\n              temp[j].count = (parseInt(temp[j].count) + parseInt(data[i].count)).toString();\n              match = true;\n          }\n      }\n      if (!match) {\n          temp.push({date: data[i].date, count: data[i].count});\n      }\n    }\n  }\n  return result;\n}\n console.log(groupCategory());\n   '},function(n,e){n.exports="class test {\n\n}\n\nexport default test;"},function(n,e){n.exports="// Given an array of meeting time intervals consisting of start and end times\xa0[[s1,e1],[s2,e2],...]\xa0(si\xa0< ei), \n// determine if a person could attend\xa0\n\n// For example,\n// Given\xa0[[0, 30],[5, 10],[15, 20]],\n// return\xa0false.\n// --------------------- \n// \u4f5c\u8005\uff1afantasiasango \n// \u6765\u6e90\uff1aCSDN \n// \u539f\u6587\uff1ahttps://blog.csdn.net/fantasiasango/article/details/52698405 \n// \u7248\u6743\u58f0\u660e\uff1a\u672c\u6587\u4e3a\u535a\u4e3b\u539f\u521b\u6587\u7ae0\uff0c\u8f6c\u8f7d\u8bf7\u9644\u4e0a\u535a\u6587\u94fe\u63a5\uff01\n\n// sweepline\n// brute force\n\n// interval = (start, end)\n//          interva1  inverval2  interval3\n// input2 : [0, 10],  [15, 20],  [0, 30], [5, 8]\n\n\n// [0..........10]\n//                     [15.....20]                    \n// [0.................................30]\n//        [5..8]\n// ---------------------------------------------       \n// [0..........10]\n//                  [11]..................30]\n//                   ^   \n//                    [15.....20]                    \n\n\n// public boolean canAttendMeetings(Interval[] intervals) {\n//     o(log n)  > o(n)\n//     Arrays.sort(intervals, new Comparator<Interval>() {\n//         public int compare(Interval a, Interval b) {\n//             return a.start - b.start;\n//         };\n//     });\n//     // sorted interal array \n//     // sweepline\n//     for (int i = 1; i < intervals.length; i++) {\n//         if (intervals[i - 1].end > intervals[i].start) {\n//             return false;\n//         }\n//     }\n// }\n\nfunction Interval(start, end) {\n     this.start = start;\n     this.end = end;\n}\n\nvar canAttendMeetings = function(intervals) {\n    let data = [];\n    for (let i = 0; i < intervals.length; i++) {\n        data.push(new Interval(intervals[i][0],intervals[i][1]));\n    }\n    data.sort((a,b) => {\n        return a.start > b.start ? 1 : -1;\n    });\n    for(var i = 1; i < data.length; i++) {\n        if(data[i - 1].end > data[i].start) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconsole.log(canAttendMeetings([[5, 10],[0, 30],[15, 20]]));"},function(n,e){n.exports="/*\n * Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei),\n \n    find the minimum number of conference rooms required.\n* For example,\n* Given [[0, 30],[5, 10],[15, 20]], return 2.\n*/\n//\n// [0............................................30]\n//      [5..........10]           \n//          [7....................20]\n//                                     [23.....27]\n//                                        [24................ 40]\n//                                             [25........35]   \n// ------------------------------------------------ \n//\n// // [5,15], [10, 20],[15, 40],[20, 30]\n// // [5..........15]\n// //      [10...............20]\n// //                   [15................................40]\n// //                       [20............30]\n// [5,t]  + 1 \n// [10,t] + 1 2\n// [15,f] - 1 1\n// [15,t] + 1 2\n// [20,f] - 1 1\n// [20,t] + 1 2\n// [30,f] - 1 1\n// [40,f] - 1 0\nclass Interval {\n    constructor(val, isStart) {\n        this.val = val;\n        this.isStart = isStart;\n    }\n}\n\nconst minMeetingRooms = intervals => {\n    if (intervals.length === 0) return 0;\n\n    let meetings = [];\n    let maxRoom = 0;\n    let room = 0;\n\n    for (let i = 0; i < intervals.length; i++) {\n        meetings.push(new Interval(intervals[i][0], true));\n        meetings.push(new Interval(intervals[i][1], false));\n    }\n\n    meetings.sort((a,b) => a.val - b.val || a.isStart);\nconsole.log(meetings);\n    for (let j = 0; j < meetings.length; j++) {\n        room = meetings[j].isStart ? room + 1 : room - 1;\n        maxRoom = Math.max(room, maxRoom)\n    }\n    return maxRoom;\n\n    // version 2. \n    // var map = {};\n    // let room = 0;\n    // let meetingRoom = 0;\n\n    // for (let i = 0; i < meetings.length; i++) {\n    //     map[meetings[i].start] = map[meetings[i].start] || 0;\n    //     map[meetings[i].start]++;\n    //     map[meetings[i].end] = map[meetings[i].end] || 0;\n    //     map[meetings[i].end]--;\n    // }\n\n    // for (let m in map) {\n    //     room += map[m];\n    //     meetingRoom = Math.max(room, meetingRoom);\n    // }\n    // return meetingRoom;\n}\nconsole.log(minMeetingRooms([ [0, 30], [5, 10], [7, 20], [23,27], [24, 40], [25, 35]]));\nconsole.log(minMeetingRooms([ [0, 30], [5, 10], [7, 20]]));\nconsole.log(minMeetingRooms([ [20, 30], [10, 20],[5,15], [15, 40] ]));\nconsole.log(minMeetingRooms([ [0, 10], [15, 20], [25, 30]]));\n\nclass t extends Map {\n    constructor(capacity) {\n        super();\n        this.c = capacity;\n        this.set('a','a');\n    }\n}\n\nconst test = new t('1');\n\nconsole.log(test.get('a'));"},function(n,e){n.exports="// Given a collection of intervals, merge all overlapping intervals.\n\n// Example 1:\n\n// Input: [[1,3],[2,6],[8,10],[15,18]]\n// Output: [[1,6],[8,10],[15,18]]\n// Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\n// Example 2:\n\n// Input: [[1,4],[4,5]]\n// Output: [[1,5]]\n// Explanation: Intervals [1,4] and [4,5] are considerred overlapping.\n\n/**\n * Definition for an interval.\n * function Interval(start, end) {\n *     this.start = start;\n *     this.end = end;\n * }\n */\n/**\n * @param {Interval[]} intervals\n * @return {Interval[]}\n */\nfunction Interval(start, end) {\n    this.start = start;\n    this.end = end;\n}\n var merge = function(intervals) {\n    intervals.sort((a,b) => a.start - b.start);\n    let i = 0;\n    while (i < intervals.length - 1) {\n        if (intervals[i].end >= intervals[i + 1].start) {\n            intervals[i].end = Math.max(intervals[i].end, intervals[i + 1].end);\n            intervals.splice(i + 1,1);\n        } else i++;\n    }\n    return intervals;\n}\nconst convertToIntervals = (data) => {\n    let intervals = [];\n    for (let i = 0; i < data.length; i++) {\n        intervals.push(new Interval(data[i][0], data[i][1]));\n    }\n    return intervals;\n}\n\nlet data1 = [[1,3],[2,6],[8,10],[15,18]];\nlet data2 = [[1,4],[4,5]];\n\nlet input1 = convertToIntervals(data1);\nlet input2 = convertToIntervals(data2);\n\nconsole.log(merge(input1));\nconsole.log(merge(input2));\n"},,,function(n,e,t){n.exports=t(420)},,,,,function(n,e,t){},,function(n,e,t){},,,,function(n,e,t){},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(n,e,t){},,function(n,e,t){},,function(n,e,t){var r={"./Array/136-single-number":139,"./Array/136-single-number.js":139,"./Array/169-majority-element":140,"./Array/169-majority-element.js":140,"./Array/189-rotate-array":141,"./Array/189-rotate-array.js":141,"./Array/20-valid-parentheses":142,"./Array/20-valid-parentheses.js":142,"./Array/26-remove-duplicates-from-sorted-array":143,"./Array/26-remove-duplicates-from-sorted-array.js":143,"./Array/283-remove-zero":144,"./Array/283-remove-zero.js":144,"./Array/34-find-first-last-element-array":145,"./Array/34-find-first-last-element-array.js":145,"./Array/66-plus-one":146,"./Array/66-plus-one.js":146,"./BackTracking/22-generate-parentheses":147,"./BackTracking/22-generate-parentheses.js":147,"./BackTracking/78-subsets":148,"./BackTracking/78-subsets.js":148,"./BackTracking/90-subset-ii":149,"./BackTracking/90-subset-ii.js":149,"./BinarySearch/704-binarySearch":150,"./BinarySearch/704-binarySearch.js":150,"./BinarySearchTree/100-same-tree":151,"./BinarySearchTree/100-same-tree.js":151,"./BinarySearchTree/101-symmetric-tree":152,"./BinarySearchTree/101-symmetric-tree.js":152,"./BinarySearchTree/102-binary-tree-level-order-traversal":153,"./BinarySearchTree/102-binary-tree-level-order-traversal.js":153,"./BinarySearchTree/103-binary-tree-zigzag-level-order-traversal":154,"./BinarySearchTree/103-binary-tree-zigzag-level-order-traversal.js":154,"./BinarySearchTree/104-max-depth-of-binary-tree":155,"./BinarySearchTree/104-max-depth-of-binary-tree.js":155,"./BinarySearchTree/105-preorder-to-inorder-traversal":156,"./BinarySearchTree/105-preorder-to-inorder-traversal.js":156,"./BinarySearchTree/107-binary-tree-level-order-traversal":157,"./BinarySearchTree/107-binary-tree-level-order-traversal.js":157,"./BinarySearchTree/108-convert-array-bst":158,"./BinarySearchTree/108-convert-array-bst.js":158,"./BinarySearchTree/111-minimum-depth-of-binary-tree":159,"./BinarySearchTree/111-minimum-depth-of-binary-tree.js":159,"./BinarySearchTree/112-path-sum":160,"./BinarySearchTree/112-path-sum.js":160,"./BinarySearchTree/144-binary-tree-preorder-traversal":161,"./BinarySearchTree/144-binary-tree-preorder-traversal.js":161,"./BinarySearchTree/145-binary-tree-postorder-traversal":162,"./BinarySearchTree/145-binary-tree-postorder-traversal.js":162,"./BinarySearchTree/199-binary-tree-right-side-view":163,"./BinarySearchTree/199-binary-tree-right-side-view.js":163,"./BinarySearchTree/200-number-island":164,"./BinarySearchTree/200-number-island.js":164,"./BinarySearchTree/200a-419-battleships-in-a-board":165,"./BinarySearchTree/200a-419-battleships-in-a-board.js":165,"./BinarySearchTree/226-invert-binary-tree":166,"./BinarySearchTree/226-invert-binary-tree.js":166,"./BinarySearchTree/230-kth-element":167,"./BinarySearchTree/230-kth-element.js":167,"./BinarySearchTree/257-binary-tree-paths":168,"./BinarySearchTree/257-binary-tree-paths.js":168,"./BinarySearchTree/513-find-bottom-left-tree-value":169,"./BinarySearchTree/513-find-bottom-left-tree-value.js":169,"./BinarySearchTree/515-largest-value-tree-row":170,"./BinarySearchTree/515-largest-value-tree-row.js":170,"./BinarySearchTree/654-maximum-binary-tree":171,"./BinarySearchTree/654-maximum-binary-tree.js":171,"./BinarySearchTree/655-PrintBST":172,"./BinarySearchTree/655-PrintBST.js":172,"./BinarySearchTree/695-max-area-island":173,"./BinarySearchTree/695-max-area-island.js":173,"./BinarySearchTree/700-searchBST":174,"./BinarySearchTree/700-searchBST.js":174,"./BinarySearchTree/94-binary-tree-inorder-traversal":175,"./BinarySearchTree/94-binary-tree-inorder-traversal.js":175,"./BinarySearchTree/98-validate-binary-search-tree":176,"./BinarySearchTree/98-validate-binary-search-tree.js":176,"./BreadthFirstSearch/127-word-ladder":177,"./BreadthFirstSearch/127-word-ladder.js":177,"./BreadthFirstSearch/752-open-the-lock":178,"./BreadthFirstSearch/752-open-the-lock.js":178,"./Combination/17-phone-letter-combine":179,"./Combination/17-phone-letter-combine.js":179,"./Combination/216-combination-sum-iii":180,"./Combination/216-combination-sum-iii.js":180,"./Combination/256-factor-cominbation":181,"./Combination/256-factor-cominbation.js":181,"./Combination/39-combination-sum":182,"./Combination/39-combination-sum.js":182,"./Combination/40-combination-sum-ii":183,"./Combination/40-combination-sum-ii.js":183,"./Combination/77-combinations":184,"./Combination/77-combinations.js":184,"./DepthFirstSearch/733-fill-color":185,"./DepthFirstSearch/733-fill-color.js":185,"./DepthFirstSearch/897-increasing-order-search-tree":186,"./DepthFirstSearch/897-increasing-order-search-tree.js":186,"./DynamicProgramming/322-coin-change":187,"./DynamicProgramming/322-coin-change.js":187,"./HashTable/1-two-sum":188,"./HashTable/1-two-sum.js":188,"./HashTable/217-contains-duplicate":189,"./HashTable/217-contains-duplicate.js":189,"./HashTable/3-longest_substring_no_repeat":190,"./HashTable/3-longest_substring_no_repeat.js":190,"./HashTable/766-toeplitz-matrix":191,"./HashTable/766-toeplitz-matrix.js":191,"./HashTable/771-jewels-and-stones":192,"./HashTable/771-jewels-and-stones.js":192,"./HashTable/804-morse-code":193,"./HashTable/804-morse-code.js":193,"./LinkedList/116-pointers-next-right-node":194,"./LinkedList/116-pointers-next-right-node.js":194,"./LinkedList/141-linked-list-cycle":195,"./LinkedList/141-linked-list-cycle.js":195,"./LinkedList/148-sorted-linked-list":196,"./LinkedList/148-sorted-linked-list.js":196,"./LinkedList/19-remove-nth-node-from-end-of-list":197,"./LinkedList/19-remove-nth-node-from-end-of-list.js":197,"./LinkedList/2-add-two-linked":198,"./LinkedList/2-add-two-linked.js":198,"./LinkedList/203-remove-linked-list-elements":199,"./LinkedList/203-remove-linked-list-elements.js":199,"./LinkedList/206-reverse-linked-list":200,"./LinkedList/206-reverse-linked-list.js":200,"./LinkedList/21-merge-two-sorted-lists":201,"./LinkedList/21-merge-two-sorted-lists.js":201,"./LinkedList/234-palindrome-linked-list":202,"./LinkedList/234-palindrome-linked-list.js":202,"./LinkedList/237-delete-linked-list":203,"./LinkedList/237-delete-linked-list.js":203,"./LinkedList/83-remove-duplicates-from-sorted-list":204,"./LinkedList/83-remove-duplicates-from-sorted-list.js":204,"./LinkedList/876-middle-of-the-linked-list":205,"./LinkedList/876-middle-of-the-linked-list.js":205,"./Permutations/131-palindrome-partition":206,"./Permutations/131-palindrome-partition.js":206,"./Permutations/46-permutations":207,"./Permutations/46-permutations.js":207,"./Permutations/47-permutations-ii":208,"./Permutations/47-permutations-ii.js":208,"./Permutations/60-permutation-sequence":209,"./Permutations/60-permutation-sequence.js":209,"./Permutations/93-restore-ip-addresses":210,"./Permutations/93-restore-ip-addresses.js":210,"./TwoPointer/11-container-with-most-water":211,"./TwoPointer/11-container-with-most-water.js":211,"./TwoPointer/15-3sum":212,"./TwoPointer/15-3sum.js":212,"./TwoPointer/167-two-sum-II":213,"./TwoPointer/167-two-sum-II.js":213,"./_misc/122-best-time-to-buy-and-sell-stock":214,"./_misc/122-best-time-to-buy-and-sell-stock.js":214,"./_misc/125-valid-palindrome":215,"./_misc/125-valid-palindrome.js":215,"./_misc/344-reverse-string":216,"./_misc/344-reverse-string.js":216,"./_misc/7-revese-integer":217,"./_misc/7-revese-integer.js":217,"./_misc/Big-O":218,"./_misc/Big-O.js":218,"./_misc/GroupData":219,"./_misc/GroupData.js":219,"./_misc/k-test":220,"./_misc/k-test.js":220,"./sweepline/252-meeting-room":221,"./sweepline/252-meeting-room.js":221,"./sweepline/253-meeting-room-ii":222,"./sweepline/253-meeting-room-ii.js":222,"./sweepline/56-merge-interval":223,"./sweepline/56-merge-interval.js":223};function a(n){var e=i(n);return t(e)}function i(n){var e=r[n];if(!(e+1)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return e}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id=418},,function(n,e,t){"use strict";t.r(e);for(var r=t(0),a=t.n(r),i=t(34),s=t.n(i),o=t(422),l=(t(231),t(25)),u=t(26),d=t(28),c=t(27),m=t(29),h=t(424),p=t(423),f=t(421),g=(t(233),function(){return a.a.createElement("header",{id:"header"},a.a.createElement("div",{className:"avatar"},"TC"),a.a.createElement("nav",{className:"links"},a.a.createElement("ul",null,a.a.createElement("li",null,a.a.createElement(f.a,{to:"/"},"Home")),a.a.createElement("li",null,a.a.createElement(f.a,{to:"/resume"},"resume")),a.a.createElement("li",null,a.a.createElement(f.a,{to:"/leetcode"},"leetcode")))))}),v=function(){return a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon profile"}),"Tony Chen - Software Engineer"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null,"Dear Sir or Madam,"),a.a.createElement("p",null,"If your company can benefit from the contributions of a resourceful and knowledgeable technical professional who seeks to develop solutions with the end user in mind, then i am the candidate that you seek."),a.a.createElement("p",null,"Throughout my career, I have become proficient in numerous platforms, web technologies, programming languages, and application development tools, I constantly strive to find the best solutions, and work hard to ensure that each new feature implemented provides technological advancements for system users. I have played instrumental roles in various project and been involved in the project lifecycle development."),a.a.createElement("p",null,"I am a quick learner with the proven ability to clearly understand problems and find positive solutions through critical thinking, diligence and excellent communication skills. with a solid reputation as dynamic problem solver and out of the box thinker, i consistently deliver solutions that exceed user expectation. I am confident I can do the same of you."),a.a.createElement("p",null,"I am confident in my ability to meet and exceed your expectation for Web Application engineer, and i believe my background provides the skills you require for this position, and i would appreciate the opportunity to further discuss my credentials ability with you during the personal interview."),a.a.createElement("p",null,"Thanks you for your time Interest and consideration."),a.a.createElement("p",null,"Sincerely,"),a.a.createElement("p",null,a.a.createElement("b",null,"Tony Chen")))))},b=(t(237),function(n){function e(){var n;return Object(l.a)(this,e),(n=Object(d.a)(this,Object(c.a)(e).call(this))).state={},n}return Object(m.a)(e,n),Object(u.a)(e,[{key:"render",value:function(){return a.a.createElement("div",null,a.a.createElement("div",{className:"main"},a.a.createElement("div",{className:"personal-info-block"},a.a.createElement("div",{className:"text-block"},a.a.createElement("div",{className:"name"},"Tony Chen"),a.a.createElement("div",{className:"current-position setting--primary-text"},"Software Engineer"),a.a.createElement("div",{className:"contacts"},a.a.createElement("div",{className:"city"},"California, 95131, USA")))),a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon profile"}),"Superior Applications Development"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null,"Highly Skilled in designing, coding, and testing innovative and effective software, User interface(UI), and e-commerce solutions. Strong project leader accomplished in directing cradle-to-grave software developer life cycle( SDLC). Proficient in industry dominant languageds, methodologies, standards, and the best practices, Superior planner and proritlier with a track record for on-time project delivery."),a.a.createElement("p",null,"Seeking a software development position that demands utilization of my knowledge and skills. I have years experience in both development and research positions. I create software with user in mind. I understand the importance of maintainable source code \xa0and I also constantly learning new technologies.")))),a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon work"}),"Career Success"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-title"},"Software Engineer at  8x8 Inc., San Jose"),a.a.createElement("div",{className:"item-caption setting--primary-text"},"October 2015\xa0\xa0\u2013\xa0\xa02018"),a.a.createElement("div",{className:"item-description"},a.a.createElement("ul",null,a.a.createElement("li",null,"Leveraged ReactJS and Electron to build presentation layer for cross-platform telephony / chat desktop applications"),a.a.createElement("li",null,"Experienced in React JS and working with Redux architecture.\xa0"),a.a.createElement("li",null,"Experienced in developing React components. Used Axios with ReactJS for making AJAX Calls. Worked on Webpack for build and webpack-dev-server a server.\xa0"),a.a.createElement("li",null,"Design reusable user interface components in ReactJS and Javascript ES6, Managed application state using Redux"),a.a.createElement("li",null,"Write unit test in Jest and Enzyme to save development efforts"),a.a.createElement("li",null,"Contribute in continuous integration and continuous deployment making pull request using GitLab and Jenkins"),a.a.createElement("li",null,"Working in Agile Methodology and team Scrum, and work with story task"),a.a.createElement("li",null,"Ability and experience to work in a critical, dynamic and challenging environment."),a.a.createElement("li",null,"Excellent understanding of system design and analysis concepts."),a.a.createElement("li",null,"Document work using self documenting technique.")))),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-title"},"Software Engineer at  Mobile Programming LLC."),a.a.createElement("div",{className:"item-caption setting--primary-text"},"October 2005\xa0\xa0\u2013\xa0\xa0October 2015"),a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null,a.a.createElement("strong",null,"A-G Software & Technology, Inc. Ontario, California \xa0")),a.a.createElement("p",null,a.a.createElement("strong",null,"ASP.NET C# / MVC / IOC/ JQuery / KnockoutJS")),a.a.createElement("ul",null,a.a.createElement("li",null,"Resharper, Ninject, Nunit, LINQ, and Design Patterns."),a.a.createElement("li",null,"Using best practices, integrated SAP BusinessObjects (.NET 3.5) with ASP.NET MVC 3 (.NET 4.0)."),a.a.createElement("li",null,"Using Dependency Injection for software design pattern."),a.a.createElement("li",null,"Create user screens from design comps following project style guidelines."),a.a.createElement("li",null,"Create and unit test intricate client side interactions with jQuery and KnockoutJS(MVVM)/DurandalJS(SPA)."),a.a.createElement("li",null,"Create Mobile Site , using AngularJS (SPA )"),a.a.createElement("li",null,"Using Bootstrap do developer a responsive mobile website."),a.a.createElement("li",null,"Develop complex MVC Controller, ViewModels and Helper methods linked to backend database."),a.a.createElement("li",null,"Developed deep understanding of NHibernate configuration and usage."),a.a.createElement("li",null,"Utilized Cassette for combining and optimizing CSS and JavaScript files."),a.a.createElement("li",null,"Attend design meetings and provide feedback based on professional experience."),a.a.createElement("li",null,"Provided mentorship, training and resources to team members.")),a.a.createElement("p",null,a.a.createElement("strong",null,"Prediction Science (ASP.NET C# ) Irvine, California\xa0")),a.a.createElement("ul",null,a.a.createElement("li",null,"Developing code using ASP.net and MS-SQL."),a.a.createElement("li",null,"Working with XML, SOAP, and Web Services\xa0"),a.a.createElement("li",null,"Proficient in JavaScript/AJAX\xa0"),a.a.createElement("li",null,"Create system design documents and devise an implementation strategy for the projects."),a.a.createElement("li",null,"Structure and view data online via the web.\xa0"),a.a.createElement("li",null,"Developed and tested projects according to specifications.")),a.a.createElement("p",null,a.a.createElement("strong",null,"AVM LP (ASP.NET C# / AJAX) Boca Raton, Florida")),a.a.createElement("ul",null,a.a.createElement("li",null,"Building, deploying, and managing enterprise Web Portal Content Management."),a.a.createElement("li",null,"Create Custom Chart \u2013 Pie Chart, Line Chart, and Bar Chart. \xa0"),a.a.createElement("li",null,"Testify the functionality of the Web Product and helped overcome problems regarding UI"),a.a.createElement("li",null,"Web applications written primarily in ASP.NET C# 3.5 / 4.0"),a.a.createElement("li",null,"Applied knowledge of prototype process design and usability process test."),a.a.createElement("li",null,"Recognize the business objectives and constraints and plan accordingly"),a.a.createElement("li",null,"Participate in all phases of projects, from requirements gathering & estimating to deployment"),a.a.createElement("li",null,"Experienced the development and implementation of user interface for commercial web-based")),a.a.createElement("p",null,a.a.createElement("strong",null,"Four Seasons Sunrooms (className ASP / ASP.NET / AJAX) Long Island, NY\xa0")),a.a.createElement("ul",null,a.a.createElement("li",null,"User Interface presentation using Photoshop and cascading style sheet ",a.a.createElement("strong",null,"CSS"),".\xa0"),a.a.createElement("li",null,"Designed database schema"),a.a.createElement("li",null,"Intranet and Website Maintenance and Updates\xa0"),a.a.createElement("li",null,"Translating business requirements into technical architecture and specification\xa0"),a.a.createElement("li",null,"Interacting with a team of developers\xa0"),a.a.createElement("li",null,"Documenting development processes, methodology and standards\xa0"),a.a.createElement("li",null,"Communicating with clients and vendors"))))),a.a.createElement("div",{className:"experience-group"},a.a.createElement("div",{className:"group-title"},a.a.createElement("div",{className:"group-title-icon education"}),"Education"),a.a.createElement("div",{className:"experience-item"},a.a.createElement("div",{className:"item-title"},"Bachelor of Art:  Computer Science, University of New York, New York"),a.a.createElement("div",{className:"item-caption setting--primary-text"},"October 1998\xa0\xa0\u2013\xa0\xa0October 2002"),a.a.createElement("div",{className:"item-description"},a.a.createElement("p",null))))),a.a.createElement("div",{className:"aside"},a.a.createElement("div",{className:"aside-group details"},a.a.createElement("div",{className:"title"},"Details"),a.a.createElement("div",{className:"section"},a.a.createElement("div",{className:"text"},"2014 Nunes Dr, California, 95131, USA"),a.a.createElement("div",{className:"text"},"561-901-5698"),a.a.createElement("div",{className:"text setting--primary-text"},"tchen427@gmail.com")),a.a.createElement("div",{className:"section"},a.a.createElement("div",{className:"label"},"Nationality"),a.a.createElement("div",{className:"text"},"Chinese, Asian"))),a.a.createElement("div",{className:"aside-group"},a.a.createElement("div",{className:"title with-icon"},a.a.createElement("div",{className:"title-icon skills"}),"Skills"),a.a.createElement("div",{className:"section"},a.a.createElement("div",{className:"text"},"ReactJS / Redux"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"Javascript / ES5 / ES6"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"CSS / Sass / Stylus"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"NodeJS / npm / "),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"Webpack / Gulp / Grant"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"})),a.a.createElement("div",{className:"text"},"Gitlab/ Github"),a.a.createElement("div",{className:"progress"},a.a.createElement("div",{className:"progress-inner setting--primary-background"}))))))}}]),e}(a.a.Component)),y=t(35),x=t(224),w=t(93),k=t.n(w),E=(t(414),t(416),{name:"LeetCode - Algorithm",toggled:!0,children:[{name:"Array",type:"folder",children:[{type:"file",name:"169-majority-element.js"},{type:"file",name:"189-rotate-array.js"},{type:"file",name:"20-valid-parentheses.js"},{type:"file",name:"26-remove-duplicates-from-sorted-array.js"},{type:"file",name:"283-remove-zero.js"},{type:"file",name:"34-find-first-last-element-array.js"}]},{name:"BackTracking",type:"folder",children:[{type:"file",name:"78-subsets.js"},{type:"file",name:"90-subset-ii.js"}]},{name:"BreadthFirstSearch",type:"folder",children:[{type:"file",name:"127-word-ladder.js"}]},{name:"BinarySearch",type:"folder",children:[{type:"file",name:"704-binarySearch.js"}]},{name:"BinarySearchTree",type:"folder",children:[{type:"file",name:"100-same-tree.js"},{type:"file",name:"101-symmetric-tree.js"},{type:"file",name:"102-binary-tree-level-order-traversal.js"},{type:"file",name:"103-binary-tree-zigzag-level-order-traversal.js"},{type:"file",name:"104-max-depth-of-binary-tree.js"},{type:"file",name:"105-preorder-to-inorder-traversal.js"},{type:"file",name:"107-binary-tree-level-order-traversal.js"},{type:"file",name:"108-convert-array-bst.js"},{type:"file",name:"111-minimum-depth-of-binary-tree.js"},{type:"file",name:"112-path-sum.js"},{type:"file",name:"144-binary-tree-preorder-traversal.js"},{type:"file",name:"145-binary-tree-postorder-traversal.js"},{type:"file",name:"199-binary-tree-right-side-view.js"},{type:"file",name:"200-number-island.js"},{type:"file",name:"200a-419-battleships-in-a-board.js"},{type:"file",name:"226-invert-binary-tree.js"},{type:"file",name:"230-kth-element.js"},{type:"file",name:"257-binary-tree-paths.js"},{type:"file",name:"513-find-bottom-left-tree-value.js"},{type:"file",name:"515-largest-value-tree-row.js"},{type:"file",name:"654-maximum-binary-tree.js"},{type:"file",name:"655-PrintBST.js"},{type:"file",name:"695-max-area-island.js"},{type:"file",name:"700-searchBST.js"},{type:"file",name:"94-binary-tree-inorder-traversal.js"},{type:"file",name:"98-validate-binary-search-tree.js"}]},{name:"Combination",type:"folder",children:[{type:"file",name:"17-phone-letter-combine.js"},{type:"file",name:"216-combination-sum-iii.js"},{type:"file",name:"256-factor-cominbation.js"},{type:"file",name:"39-combination-sum.js"},{type:"file",name:"40-combination-sum-ii.js"},{type:"file",name:"77-combinations.js"}]},{name:"DynamicProgramming",type:"folder",children:[{type:"file",name:"322-coin-change.js"}]},{name:"HashTable",type:"folder",children:[{type:"file",name:"1-two-sum.js"},{type:"file",name:"217-contains-duplicate.js"},{type:"file",name:"766-toeplitz-matrix.js"},{type:"file",name:"771-jewels-and-stones.js"},{type:"file",name:"804-morse-code.js"},{type:"file",name:"3-longest_substring_no_repeat.js"}]},{name:"LinkedList",type:"folder",children:[{type:"file",name:"116-pointers-next-right-node.js"},{type:"file",name:"141-linked-list-cycle.js"},{type:"file",name:"148-sorted-linked-list.js"},{type:"file",name:"19-remove-nth-node-from-end-of-list.js"},{type:"file",name:"2-add-two-linked.js"},{type:"file",name:"203-remove-linked-list-elements.js"},{type:"file",name:"206-reverse-linked-list.js"},{type:"file",name:"21-merge-two-sorted-lists.js"},{type:"file",name:"234-palindrome-linked-list.js"},{type:"file",name:"237-delete-linked-list.js"},{type:"file",name:"83-remove-duplicates-from-sorted-list.js"},{type:"file",name:"876-middle-of-the-linked-list.js"}]},{name:"Permutations",type:"folder",children:[{type:"file",name:"131-palindrome-partition.js"},{type:"file",name:"46-permutations.js"},{type:"file",name:"47-permutations-ii.js"},{type:"file",name:"60-permutation-sequence.js"},{type:"file",name:"93-restore-ip-addresses.js"}]},{name:"_misc",type:"folder",children:[{type:"file",name:"122-best-time-to-buy-and-sell-stock.js"},{type:"file",name:"125-valid-palindrome.js"},{type:"file",name:"344-reverse-string.js"},{type:"file",name:"7-revese-integer.js"},{type:"file",name:"Big-O.js"},{type:"file",name:"k-test.js"}]},{name:"sweepline",type:"folder",children:[{type:"file",name:"252-meeting-room.js"},{type:"file",name:"253-meeting-room-ii.js"},{type:"file",name:"56-merge-interval.js"}]},{name:"TwoPointer",type:"folder",children:[{type:"file",name:"167-two-sum-II.js"},{type:"file",name:"11-container-with-most-water.js"}]}]}),T={},S=0;S<E.children.length;S++)for(var j=0;j<E.children[S].children.length;j++)T[E.children[S].children[j].name]=t(418)("./".concat(E.children[S].name,"/").concat(E.children[S].children[j].name));var N=E,I=function(n,e){return-1!==e.name.indexOf(n)},L=function n(e,t,r){return r(t,e)||e.children&&e.children.length&&!!e.children.find(function(e){return n(e,t,r)})},O={tree:{base:{listStyle:"none",backgroundColor:"#fff",margin:0,padding:0,color:"#343d46",fontFamily:"lucida grande ,tahoma,verdana,arial,sans-serif",fontSize:"14px"},node:{base:{position:"relative"},link:{cursor:"pointer",position:"relative",padding:"0px 5px",display:"block"},activeLink:{background:"#31363F"},toggle:{base:{position:"relative",display:"inline-block",verticalAlign:"top",marginLeft:"-5px",height:"24px",width:"24px"},wrapper:{position:"absolute",top:"50%",left:"50%",margin:"-7px 0 0 -7px",height:"14px"},height:14,width:14,arrow:{fill:"#343d46",strokeWidth:0}},header:{base:{display:"inline-block",verticalAlign:"top",color:"#343d46"},connector:{width:"2px",height:"12px",borderLeft:"solid 2px black",borderBottom:"solid 2px black",position:"absolute",top:"0px",left:"-21px"},title:{lineHeight:"24px",verticalAlign:"middle"}},subtree:{listStyle:"none",paddingLeft:"19px"},loading:{color:"#E2C089"}}}},B=function(n){function e(n){var t;return Object(l.a)(this,e),(t=Object(d.a)(this,Object(c.a)(e).call(this,n))).state={data:N,content:""},t.onToggle=t.onToggle.bind(Object(y.a)(Object(y.a)(t))),t}return Object(m.a)(e,n),Object(u.a)(e,[{key:"componentDidMount",value:function(){this.setState({content:T["1-two-sum.js"]}),k.a.highlightAll()}},{key:"componentDidUpdate",value:function(){k.a.highlightAll()}},{key:"onToggle",value:function(n,e){this.state.cursor&&this.setState({cursor:{active:!1}}),n.active=!0,n.children&&(n.toggled=e),this.setState({cursor:n}),"file"===n.type&&this.setState({content:T[n.name]})}},{key:"onFilterMouseUp",value:function(n){var e=n.target.value.trim();if(!e)return this.setState({data:N});var t=function n(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:I;if(r(t,e)||!e.children)return e;var a=e.children.filter(function(n){return L(n,t,r)}).map(function(e){return n(e,t,r)});return Object.assign({},e,{children:a})}(N,e);t=function n(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:I,a=e.children;if(!a||0===a.length)return Object.assign({},e,{toggled:!1});var i=e.children.filter(function(n){return L(n,t,r)}),s=i.length>0;return s&&(a=i.map(function(e){return n(e,t,r)})),Object.assign({},e,{children:a,toggled:s})}(t,e),this.setState({data:t})}},{key:"render",value:function(){return a.a.createElement("div",{className:"section group"},a.a.createElement("div",{className:"col span_1_of_2"},a.a.createElement("br",null),a.a.createElement("input",{className:"form-control",onKeyUp:this.onFilterMouseUp.bind(this),placeholder:"Search the topic...",type:"text"}),a.a.createElement("br",null),a.a.createElement("br",null),a.a.createElement(x.Treebeard,{style:O,data:this.state.data,onToggle:this.onToggle})),a.a.createElement("div",{className:"col span_2_of_2"},this.state.content&&a.a.createElement("pre",null,a.a.createElement("code",{className:"language-javascript"},this.state.content))))}}]),e}(a.a.Component),A=function(n){function e(){return Object(l.a)(this,e),Object(d.a)(this,Object(c.a)(e).apply(this,arguments))}return Object(m.a)(e,n),Object(u.a)(e,[{key:"render",value:function(){return a.a.createElement("div",{className:"body--share"},a.a.createElement("div",{className:"headerTop"}),a.a.createElement(g,null),a.a.createElement("div",{className:"preview-box"},a.a.createElement("div",{className:"container"},a.a.createElement(h.a,null,a.a.createElement(p.a,{exact:!0,path:"/",component:v}),a.a.createElement(p.a,{path:"/resume",component:b}),a.a.createElement(p.a,{path:"/leetcode",component:B})))))}}]),e}(r.Component);Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));s.a.render(a.a.createElement(o.a,null,a.a.createElement(A,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(n){n.unregister()})}]),[[226,2,1]]]);
//# sourceMappingURL=main.168a802e.chunk.js.map